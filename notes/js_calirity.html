<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JsClarity</title>
    <link rel="stylesheet" href="./cm.css">
</head>
<body>
    <!-- JavaScript DOM Manipulation -->
<div class="section"> 
    <h2>73. JavaScript DOM Manipulation</h2>
    <p>DOM manipulation involves interacting with and modifying the HTML structure of a webpage using JavaScript.</p>
    <ul>
        <li><strong>Selecting Elements:</strong> Use methods like <code>getElementById</code>, <code>querySelector</code>, and <code>getElementsByClassName</code> to select elements from the DOM.</li>
        <pre>
const elementById = document.getElementById('myElement');
const elementByClass = document.getElementsByClassName('myClass')[0];
const elementByQuery = document.querySelector('.myClass');
        </pre>

        <li><strong>Manipulating Elements:</strong> Change the content, attributes, and styles of selected elements.</li>
        <pre>
const element = document.querySelector('#myElement');
element.textContent = 'New Content';
element.setAttribute('data-info', 'example');
element.style.color = 'blue';
        </pre>

        <li><strong>Creating and Appending Elements:</strong> Create new elements and add them to the DOM.</li>
        <pre>
const newElement = document.createElement('div');
newElement.textContent = 'I am a new element!';
document.body.appendChild(newElement);
        </pre>

        <li><strong>Removing Elements:</strong> Remove elements from the DOM.</li>
        <pre>
const elementToRemove = document.querySelector('#removeMe');
elementToRemove.parentNode.removeChild(elementToRemove);
        </pre>

        <li><strong>Event Handling:</strong> Attach event listeners to elements to respond to user interactions.</li>
        <pre>
const button = document.querySelector('#myButton');
button.addEventListener('click', () => {
  alert('Button clicked!');
});
        </pre>
    </ul>
</div>

<!-- JavaScript Event Handling -->
<div class="section">
    <h2>74. JavaScript Event Handling</h2>
    <p>Event handling in JavaScript allows you to respond to user interactions and other events that occur in the browser.</p>
    <ul>
        <li><strong>Event Listeners:</strong> Attach event listeners to elements to execute code in response to specific events.</li>
        <pre>
document.querySelector('#myButton').addEventListener('click', function() {
  console.log('Button was clicked!');
});
        </pre>

        <li><strong>Event Objects:</strong> The event object provides details about the event that occurred.</li>
        <pre>
document.querySelector('#myButton').addEventListener('click', function(event) {
  console.log(event.type); // click
  console.log(event.target); // The element that was clicked
});
        </pre>

        <li><strong>Event Delegation:</strong> Use event delegation to handle events for multiple child elements using a common parent.</li>
        <pre>
document.querySelector('#parentElement').addEventListener('click', function(event) {
  if (event.target && event.target.matches('button')) {
    console.log('Button inside parent was clicked!');
  }
});
        </pre>

        <li><strong>Event Bubbling and Capturing:</strong> Understand the event propagation phases. Bubbling occurs from the target element up to the root, while capturing occurs from the root down to the target element.</li>
        <pre>
document.querySelector('#parentElement').addEventListener('click', () => {
  console.log('Parent clicked!');
}, true); // Capturing phase

document.querySelector('#childElement').addEventListener('click', () => {
  console.log('Child clicked!');
}, false); // Bubbling phase
        </pre>

        <li><strong>Removing Event Listeners:</strong> Use <code>removeEventListener</code> to detach event handlers.</li>
        <pre>
function handleClick() {
  console.log('Button was clicked!');
}

const button = document.querySelector('#myButton');
button.addEventListener('click', handleClick);
button.removeEventListener('click', handleClick);
        </pre>
    </ul>
</div>

<!-- JavaScript AJAX and Fetch API -->
<div class="section">
    <h2>75. JavaScript AJAX and Fetch API</h2>
    <p>AJAX and the Fetch API are used to make asynchronous requests to the server and handle responses without reloading the page.</p>
    <ul>
        <li><strong>AJAX (Asynchronous JavaScript and XML):</strong> Use the <code>XMLHttpRequest</code> object to make asynchronous requests.</li>
        <pre>
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true);
xhr.onload = function() {
  if (xhr.status >= 200 && xhr.status < 300) {
    console.log(xhr.responseText);
  } else {
    console.error('Request failed');
  }
};
xhr.send();
        </pre>

        <li><strong>Fetch API:</strong> A modern and more powerful alternative to <code>XMLHttpRequest</code> for making network requests.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Fetch error:', error));
        </pre>

        <li><strong>Handling Responses:</strong> Process and handle data received from the server.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    // Process the data
    console.log(data);
  })
  .catch(error => {
    // Handle errors
    console.error('Error:', error);
  });
        </pre>

        <li><strong>Sending Data:</strong> Send data to the server using POST requests.</li>
        <pre>
fetch('https://api.example.com/submit', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ key: 'value' })
})
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Abort Requests:</strong> Cancel an ongoing request using the <code>AbortController</code>.</li>
        <pre>
const controller = new AbortController();
const signal = controller.signal;

fetch('https://api.example.com/data', { signal })
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('Fetch aborted');
    } else {
      console.error('Error:', error);
    }
  });

// Abort the fetch request
controller.abort();
        </pre>
    </ul>
</div>

<!-- JavaScript Web APIs -->
<div class="section">
    <h2>76. JavaScript Web APIs</h2>
    <p>Web APIs are provided by the browser to enable interaction with different features and services.</p>
    <ul>
        <li><strong>Geolocation API:</strong> Get the geographic position of the user.</li>
        <pre>
navigator.geolocation.getCurrentPosition(position => {
  console.log(position.coords.latitude, position.coords.longitude);
});
        </pre>

        <li><strong>Local Storage and Session Storage:</strong> Store data on the client side. Local storage persists across sessions, while session storage lasts only for the duration of the page session.</li>
        <pre>
localStorage.setItem('key', 'value');
const value = localStorage.getItem('key');
console.log(value);

sessionStorage.setItem('key', 'value');
const sessionValue = sessionStorage.getItem('key');
console.log(sessionValue);
        </pre>

        <li><strong>Canvas API:</strong> Draw graphics on the web page using the <code>canvas</code> element.</li>
        <pre>
const canvas = document.querySelector('canvas');
const context = canvas.getContext('2d');
context.fillStyle = 'red';
context.fillRect(10, 10, 100, 100);
        </pre>

        <li><strong>WebSockets:</strong> Establish a persistent connection between the client and server for real-time communication.</li>
        <pre>
const socket = new WebSocket('wss://example.com/socket');
socket.onopen = () => {
  socket.send('Hello Server!');
};
socket.onmessage = event => {
  console.log('Message from server:', event.data);
};
        </pre>

        <li><strong>Service Workers:</strong> Run background scripts to handle caching and background sync, allowing for offline functionality.</li>
        <pre>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/service-worker.js')
    .then(registration => console.log('Service Worker registered:', registration))
    .catch(error => console.error('Service Worker registration failed:', error));
}
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling and Debugging -->
<div class="section">
    <h2>77. JavaScript Error Handling and Debugging</h2>
    <p>Effective error handling and debugging are crucial for developing robust JavaScript applications.</p>
    <ul>
        <li><strong>Debugging Tools:</strong> Use browser developer tools to inspect elements, debug code, and analyze network requests.</li>
        <pre>
console.log('Debugging message'); // Log messages to console
console.dir(object); // Inspect properties of an object
        </pre>

        <li><strong>Breakpoints:</strong> Set breakpoints in your code to pause execution and inspect the state at specific lines.</li>
        <pre>
debugger; // Insert a debugger statement to pause code execution
        </pre>

        <li><strong>Handling Errors Gracefully:</strong> Use try-catch blocks to catch and handle errors gracefully, providing feedback to users.</li>
        <pre>
try {
  // Code that may throw an error
} catch (error) {
  console.error('Caught an error:', error);
}
        </pre>

        <li><strong>Logging and Monitoring:</strong> Implement logging to track application behavior and errors. Use tools like Sentry for error monitoring.</li>
        <pre>
function logError(error) {
  console.error('Error:', error);
  // Send error details to a logging server
}
        </pre>

        <li><strong>Profiling Performance:</strong> Use performance profiling tools to analyze and optimize code performance.</li>
        <pre>
console.profile('MyProfile');
// Code to profile
console.profileEnd('MyProfile');
        </pre>
    </ul>
</div>
<!-- JavaScript Advanced Concepts -->
<div class="section">
    <h2>78. JavaScript Advanced Concepts</h2>
    <p>Explore more sophisticated features and techniques in JavaScript to enhance your coding skills.</p>
    <ul>
        <li><strong>Closures:</strong> A closure is a function that retains access to its lexical scope even when the function is executed outside that scope.</li>
        <pre>
function outerFunction() {
  let outerVariable = 'I am outside!';
  return function innerFunction() {
    console.log(outerVariable); // Accessing outerVariable
  };
}
const closure = outerFunction();
closure(); // Logs: 'I am outside!'
        </pre>

        <li><strong>Promises:</strong> Promises represent the eventual completion (or failure) of an asynchronous operation and its resulting value.</li>
        <pre>
const promise = new Promise((resolve, reject) => {
  // Asynchronous operation
  setTimeout(() => resolve('Success'), 1000);
});

promise.then(result => console.log(result)) // Logs: 'Success'
       .catch(error => console.error(error));
        </pre>

        <li><strong>Async/Await:</strong> Syntax to work with promises more comfortably, avoiding the need for chaining.</li>
        <pre>
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}
fetchData();
        </pre>

        <li><strong>Generators:</strong> Functions that can be paused and resumed, allowing for iteration over a sequence of values.</li>
        <pre>
function* generatorFunction() {
  yield 1;
  yield 2;
  yield 3;
}
const generator = generatorFunction();
console.log(generator.next().value); // 1
console.log(generator.next().value); // 2
console.log(generator.next().value); // 3
        </pre>

        <li><strong>Iterators:</strong> Objects that provide a way to access elements in a collection one at a time.</li>
        <pre>
const array = [1, 2, 3];
const iterator = array[Symbol.iterator]();
console.log(iterator.next().value); // 1
console.log(iterator.next().value); // 2
console.log(iterator.next().value); // 3
        </pre>

        <li><strong>Symbols:</strong> Unique and immutable data types used primarily as object property keys.</li>
        <pre>
const uniqueSymbol = Symbol('description');
const obj = {
  [uniqueSymbol]: 'value'
};
console.log(obj[uniqueSymbol]); // 'value'
        </pre>

        <li><strong>Proxies:</strong> Objects that can intercept and redefine fundamental operations for another object.</li>
        <pre>
const handler = {
  get: (target, property) => {
    return property in target ? target[property] : 'Property does not exist';
  }
};
const proxy = new Proxy({}, handler);
proxy.foo = 'bar';
console.log(proxy.foo); // 'bar'
console.log(proxy.baz); // 'Property does not exist'
        </pre>

        <li><strong>Reflect:</strong> A built-in object that provides methods for interceptable operations on objects.</li>
        <pre>
const target = {};
Reflect.defineProperty(target, 'key', { value: 'value' });
console.log(target.key); // 'value'
        </pre>

        <li><strong>Modules:</strong> JavaScript modules allow you to export and import code between different files.</li>
        <pre>
// In module.js
export const pi = 3.14;
export function calculateArea(radius) {
  return pi * radius * radius;
}

// In main.js
import { pi, calculateArea } from './module.js';
console.log(pi); // 3.14
console.log(calculateArea(5)); // 78.5
        </pre>
    </ul>
</div>

<!-- JavaScript Best Practices -->
<div class="section">
    <h2>79. JavaScript Best Practices</h2>
    <p>Follow these best practices to write cleaner, more maintainable, and efficient JavaScript code.</p>
    <ul>
        <li><strong>Code Consistency:</strong> Use a consistent coding style, including naming conventions, indentation, and commenting.</li>
        <pre>
function calculateTotal(price, tax) {
  // Ensure consistent naming and indentation
  return price + tax;
}
        </pre>

        <li><strong>Use `const` and `let`: </strong> Prefer <code>const</code> for variables that do not change and <code>let</code> for those that do, avoiding the use of <code>var</code>.</li>
        <pre>
const PI = 3.14;
let radius = 5;
radius = 10;
        </pre>

        <li><strong>Avoid Global Variables:</strong> Minimize the use of global variables to avoid conflicts and unintentional side effects.</li>
        <pre>
(function() {
  const localVar = 'I am local!';
  console.log(localVar);
})();
        </pre>

        <li><strong>Handle Errors Gracefully:</strong> Always handle errors using try-catch blocks or error handling mechanisms.</li>
        <pre>
try {
  // Code that might throw an error
} catch (error) {
  console.error('Error:', error);
}
        </pre>

        <li><strong>Optimize Performance:</strong> Write efficient code and avoid performance bottlenecks. For example, minimize DOM manipulations and use debouncing for event handling.</li>
        <pre>
function debounce(func, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}
const handleResize = debounce(() => {
  console.log('Resized!');
}, 300);
window.addEventListener('resize', handleResize);
        </pre>

        <li><strong>Write Tests:</strong> Use unit tests and integration tests to ensure your code works as expected and to catch bugs early.</li>
        <pre>
describe('calculateTotal', () => {
  it('should return the sum of price and tax', () => {
    expect(calculateTotal(100, 15)).toBe(115);
  });
});
        </pre>

        <li><strong>Document Your Code:</strong> Provide clear documentation for functions, variables, and modules to make your code easier to understand and maintain.</li>
        <pre>
/**
 * Calculates the total price including tax.
 * @param {number} price - The initial price.
 * @param {number} tax - The tax amount.
 * @returns {number} The total price.
 */
function calculateTotal(price, tax) {
  return price + tax;
}
        </pre>
    </ul>
</div>

<!-- JavaScript Security -->
<div class="section">
    <h2>80. JavaScript Security</h2>
    <p>Ensure the security of your JavaScript code and protect your applications from vulnerabilities.</p>
    <ul>
        <li><strong>Input Validation:</strong> Always validate user inputs to prevent malicious data from causing security issues.</li>
        <pre>
function sanitizeInput(input) {
  return input.replace(/<\/?[^>]+>/gi, ''); // Removes HTML tags
}
        </pre>

        <li><strong>Prevent Cross-Site Scripting (XSS):</strong> Use methods like encoding and escaping to protect against XSS attacks.</li>
        <pre>
const safeString = (str) => {
  const element = document.createElement('div');
  element.textContent = str;
  return element.innerHTML;
};
        </pre>

        <li><strong>Secure JavaScript Execution:</strong> Avoid using <code>eval()</code> and other methods that execute code dynamically, as they can be exploited.</li>
        <pre>
const executeCode = (code) => {
  // Avoid using eval
  // Use safer alternatives
};
        </pre>

        <li><strong>Protect Sensitive Data:</strong> Do not hardcode sensitive data like API keys in your JavaScript code. Use environment variables or secure storage mechanisms.</li>
        <pre>
const apiKey = process.env.API_KEY; // Use environment variables
        </pre>

        <li><strong>Content Security Policy (CSP):</strong> Implement CSP headers to prevent unauthorized sources from executing scripts on your site.</li>
        <pre>
Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.com;
        </pre>

        <li><strong>Cross-Origin Resource Sharing (CORS):</strong> Configure CORS headers on your server to control which domains can access your resources.</li>
        <pre>
app.use(cors({
  origin: 'https://trusted.com'
}));
        </pre>
    </ul>
</div>
<!-- JavaScript Debugging and Tools -->
<div class="section">
    <h2>81. JavaScript Debugging and Tools</h2>
    <p>Learn how to effectively debug your JavaScript code and make use of tools to improve your development workflow.</p>
    <ul>
        <li><strong>Debugging with Console:</strong> Use <code>console.log()</code> to output values and debug issues in your code.</li>
        <pre>
console.log('Debugging value:', variable);
        </pre>

        <li><strong>Browser Developer Tools:</strong> Utilize the built-in developer tools in browsers like Chrome and Firefox to inspect elements, monitor network activity, and debug JavaScript code.</li>
        <pre>
1. Open Developer Tools (F12 or right-click and select 'Inspect').
2. Navigate to the 'Console' tab for logging and debugging.
3. Use 'Sources' tab to set breakpoints and step through code.
        </pre>

        <li><strong>Breakpoints:</strong> Set breakpoints in your code to pause execution and inspect the state of your application.</li>
        <pre>
debugger; // Insert this statement in your code to trigger a breakpoint
        </pre>

        <li><strong>Watch Expressions:</strong> Use watch expressions to monitor the value of variables in real-time while debugging.</li>
        <pre>
1. In Developer Tools, navigate to the 'Sources' tab.
2. Add variables to the 'Watch' panel to observe their values.
        </pre>

        <li><strong>Network Tab:</strong> Monitor network requests and responses to troubleshoot issues related to data fetching and API calls.</li>
        <pre>
1. Open Developer Tools and go to the 'Network' tab.
2. Observe the requests made by your application and their responses.
        </pre>

        <li><strong>Linting Tools:</strong> Use linters like ESLint to enforce coding standards and identify potential errors before running your code.</li>
        <pre>
{
  "extends": "eslint:recommended",
  "env": {
    "browser": true,
    "node": true
  }
}
        </pre>

        <li><strong>Prettier:</strong> Integrate Prettier for automatic code formatting to maintain consistent code style.</li>
        <pre>
{
  "semi": true,
  "singleQuote": true
}
        </pre>

        <li><strong>Testing Tools:</strong> Employ testing frameworks like Jest or Mocha to write and execute unit tests for your JavaScript code.</li>
        <pre>
// Using Jest
test('adds 1 + 2 to equal 3', () => {
  expect(1 + 2).toBe(3);
});
        </pre>
    </ul>
</div>

<!-- JavaScript Performance Optimization -->
<div class="section">
    <h2>82. JavaScript Performance Optimization</h2>
    <p>Optimize the performance of your JavaScript code to ensure faster execution and a better user experience.</p>
    <ul>
        <li><strong>Minimize DOM Manipulations:</strong> Reduce the number of direct DOM manipulations to improve performance. Use DocumentFragments or batch updates.</li>
        <pre>
const fragment = document.createDocumentFragment();
for (let i = 0; i < 100; i++) {
  const element = document.createElement('div');
  fragment.appendChild(element);
}
document.body.appendChild(fragment);
        </pre>

        <li><strong>Debouncing and Throttling:</strong> Implement debouncing and throttling techniques to limit the frequency of function executions, such as handling user input events.</li>
        <pre>
function debounce(func, wait) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), wait);
  };
}
const handleResize = debounce(() => console.log('Resized!'), 300);
window.addEventListener('resize', handleResize);
        </pre>

        <li><strong>Optimize Loops:</strong> Use efficient looping techniques and avoid complex operations inside loops.</li>
        <pre>
for (let i = 0, len = array.length; i < len; i++) {
  // Loop operations
}
        </pre>

        <li><strong>Minimize Memory Leaks:</strong> Ensure proper cleanup of event listeners and intervals to prevent memory leaks.</li>
        <pre>
function clearMemory() {
  window.removeEventListener('resize', handleResize);
  clearInterval(myInterval);
}
        </pre>

        <li><strong>Lazy Loading:</strong> Implement lazy loading for images and other resources to defer loading until they are needed.</li>
        <pre>
const lazyImages = document.querySelectorAll('img.lazy');
const imageObserver = new IntersectionObserver((entries) => {
  entries.forEach(entry => {
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      img.classList.remove('lazy');
      imageObserver.unobserve(img);
    }
  });
});
lazyImages.forEach(img => imageObserver.observe(img));
        </pre>

        <li><strong>Code Splitting:</strong> Use code splitting to load only the necessary code for the initial page load, and defer loading additional code as needed.</li>
        <pre>
// Using dynamic imports
import(/* webpackChunkName: "my-chunk-name" */ './module').then(module => {
  module.myFunction();
});
        </pre>

        <li><strong>Web Workers:</strong> Offload heavy computations to web workers to keep the main thread responsive.</li>
        <pre>
const worker = new Worker('worker.js');
worker.postMessage('Start computation');
worker.onmessage = (event) => console.log(event.data);
        </pre>
    </ul>
</div>

<!-- JavaScript Design Patterns -->
<div class="section">
    <h2>83. JavaScript Design Patterns</h2>
    <p>Apply design patterns to solve common problems and improve the structure and maintainability of your JavaScript code.</p>
    <ul>
        <li><strong>Module Pattern:</strong> Encapsulate functionality and create a private scope to avoid polluting the global namespace.</li>
        <pre>
const Module = (function() {
  let privateVar = 'I am private';
  return {
    publicMethod: function() {
      console.log(privateVar);
    }
  };
})();
Module.publicMethod(); // Logs: 'I am private'
        </pre>

        <li><strong>Singleton Pattern:</strong> Ensure that a class has only one instance and provide a global point of access to it.</li>
        <pre>
const Singleton = (function() {
  let instance;
  function createInstance() {
    return { name: 'Singleton' };
  }
  return {
    getInstance: function() {
      if (!instance) {
        instance = createInstance();
      }
      return instance;
    }
  };
})();
const singleton = Singleton.getInstance();
console.log(singleton.name); // 'Singleton'
        </pre>

        <li><strong>Factory Pattern:</strong> Create objects without specifying the exact class of object that will be created.</li>
        <pre>
class Car {
  constructor(make, model) {
    this.make = make;
    this.model = model;
  }
}
class CarFactory {
  createCar(make, model) {
    return new Car(make, model);
  }
}
const factory = new CarFactory();
const myCar = factory.createCar('Toyota', 'Corolla');
console.log(myCar); // Car { make: 'Toyota', model: 'Corolla' }
        </pre>

        <li><strong>Observer Pattern:</strong> Define a subscription mechanism to allow multiple objects to listen and react to events or changes.</li>
        <pre>
class Subject {
  constructor() {
    this.observers = [];
  }
  addObserver(observer) {
    this.observers.push(observer);
  }
  notifyObservers(message) {
    this.observers.forEach(observer => observer.update(message));
  }
}
class Observer {
  update(message) {
    console.log('Received:', message);
  }
}
const subject = new Subject();
const observer = new Observer();
subject.addObserver(observer);
subject.notifyObservers('Hello'); // Logs: 'Received: Hello'
        </pre>

        <li><strong>Decorator Pattern:</strong> Add additional functionality to an object dynamically without altering its structure.</li>
        <pre>
class Car {
  drive() {
    console.log('Driving');
  }
}
function addTurbo(car) {
  car.turbo = function() {
    console.log('Turbo mode');
  };
}
const myCar = new Car();
addTurbo(myCar);
myCar.drive(); // Logs: 'Driving'
myCar.turbo(); // Logs: 'Turbo mode'
        </pre>
    </ul>
</div>
<!-- JavaScript Asynchronous Programming -->
<div class="section">
    <h2>84. JavaScript Asynchronous Programming</h2>
    <p>Understand how to handle asynchronous operations in JavaScript to manage tasks that do not execute immediately.</p>
    <ul>
        <li><strong>Callbacks:</strong> Use callback functions to handle asynchronous operations and execute code after a task completes.</li>
        <pre>
function fetchData(callback) {
  setTimeout(() => {
    callback('Data fetched');
  }, 1000);
}
fetchData(data => console.log(data)); // Logs: 'Data fetched'
        </pre>

        <li><strong>Promises:</strong> Represent the eventual completion (or failure) of an asynchronous operation and its resulting value.</li>
        <pre>
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve('Data fetched'), 1000);
  });
};
fetchData().then(data => console.log(data)); // Logs: 'Data fetched'
        </pre>

        <li><strong>Async/Await:</strong> Simplify asynchronous code by using <code>async</code> functions and <code>await</code> expressions.</li>
        <pre>
async function fetchData() {
  return 'Data fetched';
}
async function getData() {
  const data = await fetchData();
  console.log(data);
}
getData(); // Logs: 'Data fetched'
        </pre>

        <li><strong>Error Handling with Promises:</strong> Use <code>catch()</code> to handle errors in promises and manage exceptions.</li>
        <pre>
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => reject('Error'), 1000);
  });
};
fetchData().catch(error => console.error(error)); // Logs: 'Error'
        </pre>

        <li><strong>Promise.all:</strong> Run multiple promises concurrently and handle their results when all of them have completed.</li>
        <pre>
const promise1 = Promise.resolve('Data 1');
const promise2 = Promise.resolve('Data 2');
Promise.all([promise1, promise2]).then(values => console.log(values)); // Logs: ['Data 1', 'Data 2']
        </pre>

        <li><strong>Promise.race:</strong> Return a promise that resolves or rejects as soon as one of the promises in the iterable resolves or rejects.</li>
        <pre>
const promise1 = new Promise((resolve) => setTimeout(resolve, 500, 'Data 1'));
const promise2 = new Promise((resolve) => setTimeout(resolve, 100, 'Data 2'));
Promise.race([promise1, promise2]).then(value => console.log(value)); // Logs: 'Data 2'
        </pre>

        <li><strong>Promise.any:</strong> Return a promise that resolves as soon as one of the promises in the iterable resolves. If no promises resolve, it rejects.</li>
        <pre>
const promise1 = Promise.reject('Error 1');
const promise2 = Promise.resolve('Data 2');
Promise.any([promise1, promise2]).then(value => console.log(value)); // Logs: 'Data 2'
        </pre>

        <li><strong>Promise.finally:</strong> Execute a final block of code regardless of whether the promise is fulfilled or rejected.</li>
        <pre>
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve('Data fetched'), 1000);
  });
};
fetchData().finally(() => console.log('Operation complete')); // Logs: 'Operation complete'
        </pre>
    </ul>
</div>

<!-- JavaScript Modules -->
<div class="section">
    <h2>85. JavaScript Modules</h2>
    <p>Learn how to use JavaScript modules to organize and manage code effectively through modularization.</p>
    <ul>
        <li><strong>ES6 Modules:</strong> Use <code>import</code> and <code>export</code> statements to work with modules in JavaScript.</li>
        <pre>
// module.js
export const greet = (name) => `Hello, ${name}`;

// main.js
import { greet } from './module.js';
console.log(greet('World')); // Logs: 'Hello, World'
        </pre>

        <li><strong>Default Exports:</strong> Export a single value or function from a module as the default export.</li>
        <pre>
export default function greet(name) {
  return `Hello, ${name}`;
}

// main.js
import greet from './module.js';
console.log(greet('World')); // Logs: 'Hello, World'
        </pre>

        <li><strong>Named Exports:</strong> Export multiple values or functions from a module using named exports.</li>
        <pre>
export const greet = (name) => `Hello, ${name}`;
export const farewell = (name) => `Goodbye, ${name}`;

// main.js
import { greet, farewell } from './module.js';
console.log(greet('World')); // Logs: 'Hello, World'
console.log(farewell('World')); // Logs: 'Goodbye, World'
        </pre>

        <li><strong>Dynamic Imports:</strong> Load modules dynamically using <code>import()</code> for code splitting and lazy loading.</li>
        <pre>
import('./module.js').then(module => {
  console.log(module.greet('World'));
});
        </pre>

        <li><strong>Module Path Resolution:</strong> Understand how module paths are resolved and how to use relative and absolute paths.</li>
        <pre>
import { greet } from './relative-path/module.js'; // Relative path
import { greet } from '/absolute-path/module.js'; // Absolute path
        </pre>

        <li><strong>CommonJS Modules:</strong> Use CommonJS module syntax in Node.js with <code>require()</code> and <code>module.exports</code>.</li>
        <pre>
// module.js
const greet = (name) => `Hello, ${name}`;
module.exports = greet;

// main.js
const greet = require('./module.js');
console.log(greet('World')); // Logs: 'Hello, World'
        </pre>

        <li><strong>Module Bundlers:</strong> Use tools like Webpack or Rollup to bundle and manage modules for deployment.</li>
        <pre>
// Webpack configuration
module.exports = {
  entry: './main.js',
  output: {
    filename: 'bundle.js',
    path: __dirname + '/dist'
  }
};
        </pre>
    </ul>
</div>

<!-- JavaScript Event Delegation -->
<div class="section">
    <h2>86. JavaScript Event Delegation</h2>
    <p>Optimize event handling by using event delegation to manage events on dynamically created elements and reduce the number of event listeners.</p>
    <ul>
        <li><strong>Concept of Event Delegation:</strong> Attach a single event listener to a parent element to handle events for its child elements.</li>
        <pre>
document.getElementById('parent').addEventListener('click', (event) => {
  if (event.target && event.target.matches('.child')) {
    console.log('Child element clicked');
  }
});
        </pre>

        <li><strong>Benefits of Event Delegation:</strong> Improve performance by reducing the number of event listeners and handle events for dynamically added elements.</li>
        <pre>
const parentElement = document.getElementById('parent');
parentElement.addEventListener('click', (event) => {
  if (event.target && event.target.classList.contains('child')) {
    console.log('Child element clicked');
  }
});
        </pre>

        <li><strong>Event Bubbling and Capturing:</strong> Understand event propagation through bubbling and capturing phases to handle events effectively.</li>
        <pre>
document.getElementById('child').addEventListener('click', () => {
  console.log('Child clicked');
}, true); // Capturing phase
        </pre>

        <li><strong>Delegation with Multiple Targets:</strong> Use event delegation to manage events for multiple child elements of a parent.</li>
        <pre>
document.getElementById('parent').addEventListener('click', (event) => {
  if (event.target.classList.contains('child1')) {
    console.log('Child 1 clicked');
  } else if (event.target.classList.contains('child2')) {
    console.log('Child 2 clicked');
  }
});
        </pre>

        <li><strong>Event Delegation with Dynamic Content:</strong> Handle events for elements added to the DOM dynamically by using event delegation.</li>
        <pre>
document.getElementById('parent').addEventListener('click', (event) => {
  if (event.target.classList.contains('dynamic')) {
    console.log('Dynamic element clicked');
  }
});
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling -->
<div class="section">
    <h2>87. JavaScript Error Handling</h2>
    <p>Learn how to handle errors gracefully in JavaScript to ensure your application can recover from issues and provide a better user experience.</p>
    <ul>
        <li><strong>try...catch:</strong> Use <code>try...catch</code> blocks to catch and handle exceptions that occur during code execution.</li>
        <pre>
try {
  // Code that may throw an error
  throw new Error('Something went wrong');
} catch (error) {
  console.error('Error:', error.message);
}
        </pre>

        <li><strong>finally Block:</strong> Use the <code>finally</code> block to execute code after <code>try</code> and <code>catch</code>, regardless of whether an error was thrown.</li>
        <pre>
try {
  // Code that may throw an error
} catch (error) {
  console.error('Error:', error.message);
} finally {
  console.log('This will run regardless of an error');
}
        </pre>

        <li><strong>throw:</strong> Manually throw errors using the <code>throw</code> statement to create custom exceptions.</li>
        <pre>
function checkNumber(num) {
  if (num <= 0) {
    throw new Error('Number must be positive');
  }
  return num;
}
checkNumber(-1); // Throws an error
        </pre>

        <li><strong>Custom Error Types:</strong> Create custom error types by extending the built-in <code>Error</code> class.</li>
        <pre>
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = 'CustomError';
  }
}
throw new CustomError('This is a custom error');
        </pre>

        <li><strong>Handling Asynchronous Errors:</strong> Handle errors in asynchronous operations using <code>catch</code> with promises or try/catch with async/await.</li>
        <pre>
async function fetchData() {
  try {
    let response = await fetch('https://api.example.com/data');
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error.message);
  }
}
fetchData();
        </pre>

        <li><strong>Global Error Handling:</strong> Handle uncaught exceptions and unhandled promise rejections globally.</li>
        <pre>
window.addEventListener('error', (event) => {
  console.error('Global error:', event.message);
});
window.addEventListener('unhandledrejection', (event) => {
  console.error('Unhandled rejection:', event.reason);
});
        </pre>
    </ul>
</div>

<!-- JavaScript Browser APIs -->
<div class="section">
    <h2>88. JavaScript Browser APIs</h2>
    <p>Explore various browser APIs provided by JavaScript to interact with and manipulate the browser environment.</p>
    <ul>
        <li><strong>DOM API:</strong> Manipulate and traverse the document object model (DOM) to dynamically change HTML and CSS.</li>
        <pre>
const element = document.getElementById('myElement');
element.textContent = 'New text content';
        </pre>

        <li><strong>Fetch API:</strong> Use the Fetch API to make network requests and handle responses.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>LocalStorage and SessionStorage:</strong> Store and retrieve data in the browser using LocalStorage (persistent) and SessionStorage (session-based).</li>
        <pre>
localStorage.setItem('key', 'value');
const value = localStorage.getItem('key');
console.log(value); // Logs: 'value'
        </pre>

        <li><strong>Geolocation API:</strong> Access the user's geographical location.</li>
        <pre>
navigator.geolocation.getCurrentPosition(position => {
  console.log('Latitude:', position.coords.latitude);
  console.log('Longitude:', position.coords.longitude);
});
        </pre>

        <li><strong>Web Storage API:</strong> Use Web Storage API to store data on the client-side.</li>
        <pre>
sessionStorage.setItem('sessionKey', 'sessionValue');
const sessionValue = sessionStorage.getItem('sessionKey');
console.log(sessionValue); // Logs: 'sessionValue'
        </pre>

        <li><strong>Canvas API:</strong> Draw graphics and animations on a web page using the Canvas API.</li>
        <pre>
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');
ctx.fillStyle = 'blue';
ctx.fillRect(10, 10, 100, 100);
        </pre>

        <li><strong>Web Workers:</strong> Offload processing to background threads using Web Workers.</li>
        <pre>
const worker = new Worker('worker.js');
worker.postMessage('Start processing');
worker.onmessage = (event) => console.log(event.data);
        </pre>

        <li><strong>Service Workers:</strong> Use service workers to cache resources and enable offline functionality.</li>
        <pre>
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('my-cache').then((cache) => cache.addAll([
      '/',
      '/styles.css',
      '/script.js'
    ]))
  );
});
        </pre>
    </ul>
</div>
<!-- JavaScript Advanced Topics -->
<div class="section">
    <h2>89. JavaScript Advanced Topics</h2>
    <p>Delve into advanced JavaScript concepts to deepen your understanding and enhance your coding skills.</p>
    <ul>
        <li><strong>Closures:</strong> Use closures to create private variables and functions that are accessible only within a specific scope.</li>
        <pre>
function makeCounter() {
  let count = 0;
  return function() {
    count++;
    return count;
  };
}
const counter = makeCounter();
console.log(counter()); // Logs: 1
console.log(counter()); // Logs: 2
        </pre>

        <li><strong>Higher-Order Functions:</strong> Work with functions that take other functions as arguments or return functions as results.</li>
        <pre>
function greet(name) {
  return `Hello, ${name}`;
}
function processUser(user, callback) {
  return callback(user);
}
console.log(processUser('Alice', greet)); // Logs: 'Hello, Alice'
        </pre>

        <li><strong>Function Currying:</strong> Transform a function with multiple arguments into a sequence of functions each with a single argument.</li>
        <pre>
function multiply(a) {
  return function(b) {
    return a * b;
  };
}
const multiplyBy2 = multiply(2);
console.log(multiplyBy2(3)); // Logs: 6
        </pre>

        <li><strong>Memoization:</strong> Optimize performance by storing the results of expensive function calls and reusing them when the same inputs occur.</li>
        <pre>
function memoize(fn) {
  const cache = new Map();
  return function(...args) {
    const key = JSON.stringify(args);
    if (cache.has(key)) {
      return cache.get(key);
    }
    const result = fn(...args);
    cache.set(key, result);
    return result;
  };
}
const fib = memoize(function(n) {
  if (n <= 1) return n;
  return fib(n - 1) + fib(n - 2);
});
console.log(fib(40)); // Logs: 102334155
        </pre>

        <li><strong>Prototypes and Inheritance:</strong> Use JavaScript prototypes to establish inheritance and share properties and methods across objects.</li>
        <pre>
function Person(name) {
  this.name = name;
}
Person.prototype.greet = function() {
  return `Hello, my name is ${this.name}`;
};
const alice = new Person('Alice');
console.log(alice.greet()); // Logs: 'Hello, my name is Alice'
        </pre>

        <li><strong>Object Destructuring:</strong> Extract values from objects and arrays into distinct variables using destructuring assignment.</li>
        <pre>
const person = { name: 'Alice', age: 25 };
const { name, age } = person;
console.log(name); // Logs: 'Alice'
console.log(age); // Logs: 25
        </pre>

        <li><strong>Spread and Rest Operators:</strong> Use the spread operator to expand elements in an array or object and the rest operator to collect multiple elements into a single array.</li>
        <pre>
const arr1 = [1, 2, 3];
const arr2 = [4, 5, ...arr1];
console.log(arr2); // Logs: [4, 5, 1, 2, 3]

function sum(...numbers) {
  return numbers.reduce((total, num) => total + num, 0);
}
console.log(sum(1, 2, 3, 4)); // Logs: 10
        </pre>

        <li><strong>ES6 Classes:</strong> Use ES6 class syntax to define classes and create objects with methods and inheritance.</li>
        <pre>
class Person {
  constructor(name) {
    this.name = name;
  }
  greet() {
    return `Hello, my name is ${this.name}`;
  }
}
const alice = new Person('Alice');
console.log(alice.greet()); // Logs: 'Hello, my name is Alice'
        </pre>

        <li><strong>Symbols:</strong> Use symbols to create unique and immutable values for object properties.</li>
        <pre>
const sym = Symbol('description');
const obj = { [sym]: 'value' };
console.log(obj[sym]); // Logs: 'value'
        </pre>

        <li><strong>Iterators and Generators:</strong> Create and manage custom iteration behavior using iterators and generators.</li>
        <pre>
function* range(start, end) {
  for (let i = start; i <= end; i++) {
    yield i;
  }
}
const iter = range(1, 5);
console.log([...iter]); // Logs: [1, 2, 3, 4, 5]
        </pre>

        <li><strong>Reflect API:</strong> Use the Reflect API to perform meta-programming operations such as defining property behavior and handling object interactions.</li>
        <pre>
const obj = { a: 1 };
Reflect.defineProperty(obj, 'b', { value: 2 });
console.log(obj.b); // Logs: 2
        </pre>

        <li><strong>Proxies:</strong> Create proxies to intercept and redefine fundamental operations on objects such as property access and function invocation.</li>
        <pre>
const handler = {
  get(target, prop, receiver) {
    return prop in target ? target[prop] : 'Property does not exist';
  }
};
const proxy = new Proxy({}, handler);
console.log(proxy.someProperty); // Logs: 'Property does not exist'
        </pre>
    </ul>
</div>

<!-- JavaScript Testing -->
<div class="section">
    <h2>90. JavaScript Testing</h2>
    <p>Implement testing strategies to ensure your JavaScript code works correctly and is free of bugs.</p>
    <ul>
        <li><strong>Unit Testing:</strong> Test individual functions or units of code to verify they work as expected using frameworks like Jest or Mocha.</li>
        <pre>
const add = (a, b) => a + b;
test('adds 1 + 2 to equal 3', () => {
  expect(add(1, 2)).toBe(3);
});
        </pre>

        <li><strong>Integration Testing:</strong> Test interactions between different units or components to ensure they work together correctly.</li>
        <pre>
const fetchData = () => {
  return new Promise((resolve) => {
    setTimeout(() => resolve('Data'), 1000);
  });
};
test('fetches data from API', async () => {
  const data = await fetchData();
  expect(data).toBe('Data');
});
        </pre>

        <li><strong>End-to-End Testing:</strong> Test the entire application workflow, including user interactions and UI elements, using tools like Cypress.</li>
        <pre>
describe('My App', () => {
  it('should display the correct title', () => {
    cy.visit('/');
    cy.title().should('include', 'My App');
  });
});
        </pre>

        <li><strong>Mocking and Stubbing:</strong> Use mocks and stubs to simulate and control external dependencies in your tests.</li>
        <pre>
const fetchData = (url) => fetch(url).then(res => res.json());
jest.mock('node-fetch', () => jest.fn(() => Promise.resolve({ json: () => Promise.resolve('Mocked Data') })));
test('fetches mocked data', async () => {
  const data = await fetchData('https://api.example.com');
  expect(data).toBe('Mocked Data');
});
        </pre>

        <li><strong>Test Coverage:</strong> Measure how much of your code is covered by tests using tools like Istanbul or NYC.</li>
        <pre>
const coverage = require('nyc');
coverage.run(); // This command generates coverage reports
        </pre>
    </ul>
</div>
<!-- JavaScript Asynchronous Programming -->
<div class="section">
    <h2>91. JavaScript Asynchronous Programming</h2>
    <p>Handle asynchronous operations in JavaScript to manage tasks such as network requests, timers, and user interactions.</p>
    <ul>
        <li><strong>Callbacks:</strong> Use callbacks to handle asynchronous operations by passing a function as an argument to be executed once a task completes.</li>
        <pre>
function fetchData(callback) {
  setTimeout(() => {
    callback('Data');
  }, 1000);
}
fetchData((data) => {
  console.log(data); // Logs: 'Data'
});
        </pre>

        <li><strong>Promises:</strong> Manage asynchronous operations with promises that represent the eventual completion or failure of an operation.</li>
        <pre>
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => resolve('Data'), 1000);
  });
};
fetchData().then(data => {
  console.log(data); // Logs: 'Data'
});
        </pre>

        <li><strong>Async/Await:</strong> Simplify asynchronous code by using `async` functions and `await` expressions to write code that looks synchronous.</li>
        <pre>
const fetchData = async () => {
  return 'Data';
};
const process = async () => {
  const data = await fetchData();
  console.log(data); // Logs: 'Data'
};
process();
        </pre>

        <li><strong>Error Handling:</strong> Manage errors in asynchronous code using `.catch()` for promises or `try/catch` blocks with async/await.</li>
        <pre>
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => reject('Error'), 1000);
  });
};
fetchData()
  .then(data => console.log(data))
  .catch(error => console.error(error)); // Logs: 'Error'

const process = async () => {
  try {
    const data = await fetchData();
    console.log(data);
  } catch (error) {
    console.error(error); // Logs: 'Error'
  }
};
process();
        </pre>

        <li><strong>Race and All:</strong> Use `Promise.all()` to wait for multiple promises to complete or `Promise.race()` to wait for the first promise to complete.</li>
        <pre>
const promise1 = new Promise((resolve) => setTimeout(() => resolve('First'), 1000));
const promise2 = new Promise((resolve) => setTimeout(() => resolve('Second'), 500));

Promise.all([promise1, promise2])
  .then(results => console.log(results)); // Logs: ['First', 'Second']

Promise.race([promise1, promise2])
  .then(result => console.log(result)); // Logs: 'Second'
        </pre>

        <li><strong>Handling Multiple Concurrent Requests:</strong> Manage multiple concurrent requests using `Promise.allSettled()` to handle both fulfilled and rejected promises.</li>
        <pre>
const promise1 = new Promise((resolve, reject) => setTimeout(() => resolve('Success'), 1000));
const promise2 = new Promise((resolve, reject) => setTimeout(() => reject('Failure'), 500));

Promise.allSettled([promise1, promise2])
  .then(results => results.forEach(result => {
    if (result.status === 'fulfilled') {
      console.log(result.value);
    } else {
      console.error(result.reason);
    }
  }));
        </pre>
    </ul>
</div>

<!-- JavaScript Event Handling -->
<div class="section">
    <h2>92. JavaScript Event Handling</h2>
    <p>Handle user interactions and browser events using JavaScript event listeners and handlers.</p>
    <ul>
        <li><strong>Event Listeners:</strong> Attach event listeners to elements to respond to user interactions such as clicks, keypresses, and form submissions.</li>
        <pre>
document.querySelector('button').addEventListener('click', () => {
  console.log('Button clicked!');
});
        </pre>

        <li><strong>Event Delegation:</strong> Use event delegation to handle events on multiple elements by attaching a single event listener to a parent element.</li>
        <pre>
document.querySelector('ul').addEventListener('click', (event) => {
  if (event.target.tagName === 'LI') {
    console.log(`List item clicked: ${event.target.textContent}`);
  }
});
        </pre>

        <li><strong>Event Bubbling and Capturing:</strong> Understand event propagation by handling events during the bubbling phase or capturing phase.</li>
        <pre>
document.querySelector('div').addEventListener('click', () => {
  console.log('Div clicked!');
}, true); // Capture phase

document.querySelector('div').addEventListener('click', () => {
  console.log('Div clicked again!');
}); // Bubble phase
        </pre>

        <li><strong>Preventing Default Behavior:</strong> Use `event.preventDefault()` to stop the default action of events such as form submissions and link navigation.</li>
        <pre>
document.querySelector('form').addEventListener('submit', (event) => {
  event.preventDefault();
  console.log('Form submission prevented.');
});
        </pre>

        <li><strong>Event Object:</strong> Access event details using the event object, which contains properties such as `type`, `target`, and `currentTarget`.</li>
        <pre>
document.querySelector('button').addEventListener('click', (event) => {
  console.log(`Event type: ${event.type}`);
  console.log(`Event target: ${event.target}`);
});
        </pre>
    </ul>
</div>

<!-- JavaScript Browser APIs -->
<div class="section">
    <h2>93. JavaScript Browser APIs</h2>
    <p>Leverage various browser APIs to interact with the browser and provide enhanced functionality in web applications.</p>
    <ul>
        <li><strong>DOM Manipulation:</strong> Use the Document Object Model (DOM) API to dynamically modify HTML and CSS content on a web page.</li>
        <pre>
document.querySelector('h1').textContent = 'Updated Heading';
document.querySelector('p').style.color = 'blue';
        </pre>

        <li><strong>Fetch API:</strong> Make network requests using the Fetch API to retrieve data from servers and handle responses asynchronously.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Local Storage and Session Storage:</strong> Store data locally in the browser using Local Storage for persistent data and Session Storage for temporary data.</li>
        <pre>
localStorage.setItem('key', 'value');
console.log(localStorage.getItem('key')); // Logs: 'value'

sessionStorage.setItem('sessionKey', 'sessionValue');
console.log(sessionStorage.getItem('sessionKey')); // Logs: 'sessionValue'
        </pre>

        <li><strong>Web Storage API:</strong> Use the Web Storage API to manage data stored in the browser's local and session storage.</li>
        <pre>
localStorage.removeItem('key');
sessionStorage.clear();
        </pre>

        <li><strong>Geolocation API:</strong> Access the user's geographical location with their consent using the Geolocation API.</li>
        <pre>
navigator.geolocation.getCurrentPosition((position) => {
  console.log(`Latitude: ${position.coords.latitude}`);
  console.log(`Longitude: ${position.coords.longitude}`);
});
        </pre>

        <li><strong>Canvas API:</strong> Draw graphics on a web page using the Canvas API, which provides a 2D drawing context.</li>
        <pre>
const canvas = document.querySelector('canvas');
const ctx = canvas.getContext('2d');
ctx.fillStyle = 'red';
ctx.fillRect(10, 10, 100, 100);
        </pre>

        <li><strong>Web Audio API:</strong> Create and manipulate audio content in web applications using the Web Audio API.</li>
        <pre>
const audioContext = new (window.AudioContext || window.webkitAudioContext)();
const oscillator = audioContext.createOscillator();
oscillator.type = 'sine';
oscillator.frequency.setValueAtTime(440, audioContext.currentTime);
oscillator.connect(audioContext.destination);
oscillator.start();
        </pre>

        <li><strong>Service Workers:</strong> Use service workers to enable offline capabilities and background synchronization for web applications.</li>
        <pre>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then((registration) => console.log('Service Worker registered:', registration))
    .catch((error) => console.error('Service Worker registration failed:', error));
}
        </pre>

        <li><strong>WebSockets:</strong> Establish real-time, full-duplex communication between the client and server using WebSockets.</li>
        <pre>
const socket = new WebSocket('ws://example.com/socket');
socket.onmessage = (event) => {
  console.log(`Message from server: ${event.data}`);
};
socket.send('Hello, server!');
        </pre>

        <li><strong>Notifications API:</strong> Display notifications to users outside the context of a web page using the Notifications API.</li>
        <pre>
if (Notification.permission === 'granted') {
  new Notification('Hello, world!');
} else if (Notification.permission !== 'denied') {
  Notification.requestPermission().then((permission) => {
    if (permission === 'granted') {
      new Notification('Hello, world!');
    }
  });
}
        </pre>
    </ul>
</div>

<!-- JavaScript Performance Optimization -->
<div class="section">
    <h2>94. JavaScript Performance Optimization</h2>
    <p>Optimize JavaScript code to enhance performance and ensure smooth user experiences in web applications.</p>
    <ul>
        <li><strong>Minification and Compression:</strong> Reduce file size by minifying and compressing JavaScript code to improve load times.</li>
        <pre>
<script src="app.min.js"></script>
        </pre>

        <li><strong>Lazy Loading:</strong> Load JavaScript code and resources only when they are needed, such as on user interaction or scroll.</li>
        <pre>
const loadModule = async () => {
  const module = await import('./module.js');
  module.default();
};
document.querySelector('button').addEventListener('click', loadModule);
        </pre>

        <li><strong>Debouncing and Throttling:</strong> Use debouncing and throttling techniques to limit the rate of function execution and improve performance during events like scrolling and resizing.</li>
        <pre>
const debounce = (func, delay) => {
  let timer;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => func(...args), delay);
  };
};
window.addEventListener('resize', debounce(() => {
  console.log('Window resized');
}, 500));
        </pre>

        <li><strong>Code Splitting:</strong> Split JavaScript code into smaller chunks that are loaded on demand, reducing initial load times and improving performance.</li>
        <pre>
import(/* webpackChunkName: "module" */ './module.js').then(module => {
  module.default();
});
        </pre>

        <li><strong>Memory Management:</strong> Optimize memory usage by avoiding memory leaks and managing resources effectively.</li>
        <pre>
let largeArray = new Array(1000000).fill('data');
largeArray = null; // Clear reference to free memory
        </pre>

        <li><strong>Profiling and Debugging:</strong> Use browser developer tools to profile and debug JavaScript code, identifying performance bottlenecks and optimizing accordingly.</li>
        <pre>
console.profile('Performance Profile');
// Code to profile
console.profileEnd();
        </pre>
    </ul>
</div>
<!-- JavaScript Error Handling -->
<div class="section">
    <h2>95. JavaScript Error Handling</h2>
    <p>Handle errors effectively in JavaScript to ensure your application remains robust and reliable.</p>
    <ul>
        <li><strong>Try/Catch:</strong> Use `try` and `catch` blocks to handle exceptions and prevent application crashes due to runtime errors.</li>
        <pre>
try {
  // Code that may throw an error
  throw new Error('Something went wrong');
} catch (error) {
  console.error('Error caught:', error.message);
}
        </pre>

        <li><strong>Finally:</strong> Use the `finally` block to execute code after `try` and `catch`, regardless of whether an error was thrown or not.</li>
        <pre>
try {
  // Code that may throw an error
} catch (error) {
  console.error('Error caught:', error.message);
} finally {
  console.log('Finally block executed');
}
        </pre>

        <li><strong>Error Object:</strong> Access properties of the `Error` object, such as `name` and `message`, to get more information about errors.</li>
        <pre>
try {
  throw new Error('Custom error message');
} catch (error) {
  console.error(`Error name: ${error.name}`);
  console.error(`Error message: ${error.message}`);
}
        </pre>

        <li><strong>Custom Errors:</strong> Create custom error types to handle specific errors in your application.</li>
        <pre>
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = 'CustomError';
  }
}
try {
  throw new CustomError('This is a custom error');
} catch (error) {
  console.error(`Error name: ${error.name}`);
  console.error(`Error message: ${error.message}`);
}
        </pre>

        <li><strong>Global Error Handling:</strong> Handle uncaught errors globally using `window.onerror` or `window.addEventListener('error')`.</li>
        <pre>
window.addEventListener('error', (event) => {
  console.error('Global error:', event.message);
});
        </pre>

        <li><strong>Promise Rejection Handling:</strong> Handle rejected promises using `.catch()` or `try/catch` with async/await to prevent unhandled promise rejections.</li>
        <pre>
const fetchData = () => {
  return new Promise((_, reject) => {
    reject('Error fetching data');
  });
};
fetchData().catch(error => {
  console.error('Promise rejection:', error);
});
        </pre>
    </ul>
</div>

<!-- JavaScript Design Patterns -->
<div class="section">
    <h2>96. JavaScript Design Patterns</h2>
    <p>Apply design patterns to write maintainable and scalable JavaScript code.</p>
    <ul>
        <li><strong>Module Pattern:</strong> Use the module pattern to encapsulate code and create private and public members.</li>
        <pre>
const Module = (() => {
  let privateVar = 'I am private';
  return {
    publicMethod: () => console.log('I am public'),
  };
})();
Module.publicMethod(); // Logs: 'I am public'
        </pre>

        <li><strong>Singleton Pattern:</strong> Ensure a class has only one instance and provide a global point of access to it.</li>
        <pre>
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this;
    }
    return Singleton.instance;
  }
}
const instance1 = new Singleton();
const instance2 = new Singleton();
console.log(instance1 === instance2); // Logs: true
        </pre>

        <li><strong>Observer Pattern:</strong> Implement the observer pattern to create a subscription mechanism where observers are notified of changes.</li>
        <pre>
class Subject {
  constructor() {
    this.observers = [];
  }
  subscribe(observer) {
    this.observers.push(observer);
  }
  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}
class Observer {
  update(data) {
    console.log('Observer received data:', data);
  }
}
const subject = new Subject();
const observer = new Observer();
subject.subscribe(observer);
subject.notify('Hello Observers!');
        </pre>

        <li><strong>Factory Pattern:</strong> Use the factory pattern to create objects without specifying the exact class of object that will be created.</li>
        <pre>
class Car {
  constructor(make) {
    this.make = make;
  }
}
class CarFactory {
  static createCar(make) {
    return new Car(make);
  }
}
const myCar = CarFactory.createCar('Toyota');
console.log(myCar.make); // Logs: 'Toyota'
        </pre>

        <li><strong>Prototype Pattern:</strong> Use the prototype pattern to create objects based on a prototype object, enabling inheritance and shared properties.</li>
        <pre>
const prototype = {
  greet() {
    console.log('Hello, ' + this.name);
  },
};
const obj = Object.create(prototype);
obj.name = 'Alice';
obj.greet(); // Logs: 'Hello, Alice'
        </pre>
    </ul>
</div>

<!-- JavaScript Best Practices -->
<div class="section">
    <h2>97. JavaScript Best Practices</h2>
    <p>Follow best practices to write clean, efficient, and maintainable JavaScript code.</p>
    <ul>
        <li><strong>Code Readability:</strong> Write code that is easy to read and understand, using descriptive variable names and consistent formatting.</li>
        <pre>
const calculateTotalPrice = (price, quantity) => {
  return price * quantity;
};
        </pre>

        <li><strong>Use Strict Mode:</strong> Enable strict mode to catch common coding errors and prevent the use of deprecated features.</li>
        <pre>
'use strict';
const x = 3.14;
console.log(x);
        </pre>

        <li><strong>Consistent Naming Conventions:</strong> Follow consistent naming conventions for variables, functions, and classes to improve code readability.</li>
        <pre>
const calculateDiscount = (amount, discountRate) => amount * discountRate;
class ShoppingCart {
  // class definition
}
        </pre>

        <li><strong>Avoid Global Variables:</strong> Minimize the use of global variables to prevent naming conflicts and unintended behavior.</li>
        <pre>
(() => {
  const localVar = 'I am local';
  console.log(localVar);
})();
        </pre>

        <li><strong>Optimize Loops:</strong> Optimize loops for performance, using efficient methods and avoiding unnecessary operations.</li>
        <pre>
const sum = (arr) => {
  let total = 0;
  for (let i = 0; i < arr.length; i++) {
    total += arr[i];
  }
  return total;
};
        </pre>

        <li><strong>Documentation:</strong> Document your code with comments and documentation to make it easier for others (and yourself) to understand and maintain.</li>
        <pre>
/**
 * Calculates the area of a rectangle.
 * @param {number} width - The width of the rectangle.
 * @param {number} height - The height of the rectangle.
 * @returns {number} The area of the rectangle.
 */
const calculateArea = (width, height) => width * height;
        </pre>

        <li><strong>Testing:</strong> Write tests to ensure your code works as expected and to catch regressions during development.</li>
        <pre>
const assert = (condition, message) => {
  if (!condition) {
    throw new Error(message);
  }
};
assert(calculateTotalPrice(5, 10) === 50, 'Test failed');
        </pre>
    </ul>
</div>
<!-- JavaScript Asynchronous Programming -->
<div class="section">
    <h2>98. JavaScript Asynchronous Programming</h2>
    <p>Understand how to handle asynchronous operations in JavaScript using callbacks, promises, and async/await.</p>
    <ul>
        <li><strong>Callbacks:</strong> Use callbacks to handle asynchronous operations, where a function is passed as an argument and executed after another function completes.</li>
        <pre>
const fetchData = (callback) => {
  setTimeout(() => {
    callback('Data received');
  }, 1000);
};
fetchData((data) => {
  console.log(data); // Logs: 'Data received'
});
        </pre>

        <li><strong>Promises:</strong> Use promises to handle asynchronous operations with `.then()` and `.catch()` for better readability and chaining.</li>
        <pre>
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Data received');
    }, 1000);
  });
};
fetchData().then(data => {
  console.log(data); // Logs: 'Data received'
}).catch(error => {
  console.error(error);
});
        </pre>

        <li><strong>Async/Await:</strong> Use `async` functions and `await` expressions to write asynchronous code that looks synchronous, making it easier to read and debug.</li>
        <pre>
const fetchData = async () => {
  return 'Data received';
};
const displayData = async () => {
  try {
    const data = await fetchData();
    console.log(data); // Logs: 'Data received'
  } catch (error) {
    console.error(error);
  }
};
displayData();
        </pre>

        <li><strong>Handling Multiple Promises:</strong> Use `Promise.all()` to handle multiple promises concurrently and `Promise.race()` to get the result of the first resolved or rejected promise.</li>
        <pre>
const promise1 = Promise.resolve('First');
const promise2 = Promise.resolve('Second');
Promise.all([promise1, promise2]).then(values => {
  console.log(values); // Logs: ['First', 'Second']
});
        </pre>

        <li><strong>Error Handling in Async/Await:</strong> Use `try/catch` blocks with `async/await` to handle errors in asynchronous code.</li>
        <pre>
const fetchData = async () => {
  throw new Error('Data fetch failed');
};
const displayData = async () => {
  try {
    const data = await fetchData();
    console.log(data);
  } catch (error) {
    console.error('Error:', error.message); // Logs: 'Error: Data fetch failed'
  }
};
displayData();
        </pre>
    </ul>
</div>

<!-- JavaScript Modules -->
<div class="section">
    <h2>99. JavaScript Modules</h2>
    <p>Organize your JavaScript code into modules to improve maintainability and reusability.</p>
    <ul>
        <li><strong>Module Export:</strong> Export functions, objects, or values from a module using `export` to make them available for import in other modules.</li>
        <pre>
// module.js
export const greet = (name) => `Hello, ${name}`;
export const PI = 3.14;
        </pre>

        <li><strong>Module Import:</strong> Import functions, objects, or values from a module using `import` in another module.</li>
        <pre>
// app.js
import { greet, PI } from './module.js';
console.log(greet('Alice')); // Logs: 'Hello, Alice'
console.log(PI); // Logs: 3.14
        </pre>

        <li><strong>Default Export:</strong> Export a single value or function as the default export from a module.</li>
        <pre>
// module.js
const greet = (name) => `Hello, ${name}`;
export default greet;
        </pre>

        <li><strong>Default Import:</strong> Import the default export from a module using a different name if desired.</li>
        <pre>
// app.js
import greet from './module.js';
console.log(greet('Alice')); // Logs: 'Hello, Alice'
        </pre>

        <li><strong>Named Exports:</strong> Export multiple values from a module and import them by their exact names.</li>
        <pre>
// module.js
export const add = (a, b) => a + b;
export const subtract = (a, b) => a - b;
        </pre>

        <li><strong>Named Imports:</strong> Import multiple named exports from a module using curly braces.</li>
        <pre>
// app.js
import { add, subtract } from './module.js';
console.log(add(2, 3)); // Logs: 5
console.log(subtract(5, 2)); // Logs: 3
        </pre>

        <li><strong>Module Aliases:</strong> Use aliases to rename imports for better code clarity or to avoid naming conflicts.</li>
        <pre>
// module.js
export const add = (a, b) => a + b;
// app.js
import { add as addition } from './module.js';
console.log(addition(2, 3)); // Logs: 5
        </pre>
    </ul>
</div>

<!-- JavaScript DOM Manipulation -->
<div class="section">
    <h2>100. JavaScript DOM Manipulation</h2>
    <p>Manipulate the Document Object Model (DOM) to dynamically change the content and structure of your web pages.</p>
    <ul>
        <li><strong>Selecting Elements:</strong> Use methods like `getElementById()`, `querySelector()`, and `getElementsByClassName()` to select DOM elements.</li>
        <pre>
const element = document.getElementById('myElement');
const elements = document.querySelectorAll('.myClass');
        </pre>

        <li><strong>Manipulating Elements:</strong> Change the content, attributes, and styles of DOM elements using properties and methods like `innerHTML`, `setAttribute()`, and `style`.</li>
        <pre>
const element = document.getElementById('myElement');
element.innerHTML = 'New content';
element.setAttribute('data-value', '123');
element.style.color = 'blue';
        </pre>

        <li><strong>Creating and Removing Elements:</strong> Create new DOM elements using `createElement()` and remove elements using `removeChild()` or `remove()`.</li>
        <pre>
const newElement = document.createElement('div');
newElement.textContent = 'I am a new element';
document.body.appendChild(newElement);
const oldElement = document.getElementById('oldElement');
oldElement.remove();
        </pre>

        <li><strong>Event Handling:</strong> Add event listeners to elements to respond to user actions such as clicks, key presses, and form submissions.</li>
        <pre>
const button = document.getElementById('myButton');
button.addEventListener('click', () => {
  alert('Button clicked');
});
        </pre>

        <li><strong>Event Delegation:</strong> Use event delegation to handle events for multiple elements efficiently by attaching a single event listener to a common parent.</li>
        <pre>
document.getElementById('parentElement').addEventListener('click', (event) => {
  if (event.target && event.target.matches('.childElement')) {
    console.log('Child element clicked');
  }
});
        </pre>

        <li><strong>Form Handling:</strong> Access and manipulate form elements, validate user input, and handle form submissions.</li>
        <pre>
const form = document.getElementById('myForm');
form.addEventListener('submit', (event) => {
  event.preventDefault();
  const formData = new FormData(form);
  console.log('Form data:', formData.get('inputName'));
});
        </pre>

        <li><strong>Animating Elements:</strong> Use JavaScript to create animations by changing styles or using the Web Animations API.</li>
        <pre>
const element = document.getElementById('animatedElement');
element.style.transition = 'transform 1s';
element.style.transform = 'translateX(100px)';
        </pre>
    </ul>
</div>
<!-- JavaScript Error Handling -->
<div class="section">
    <h2>101. JavaScript Error Handling</h2>
    <p>Learn how to handle errors in JavaScript to improve the reliability and user experience of your applications.</p>
    <ul>
        <li><strong>Try/Catch Statement:</strong> Use the `try` block to execute code that may throw an error and the `catch` block to handle the error if one occurs.</li>
        <pre>
try {
  // Code that may throw an error
  throw new Error('Something went wrong');
} catch (error) {
  console.error('Error:', error.message);
}
        </pre>

        <li><strong>Finally Block:</strong> Use the `finally` block to execute code after the `try` and `catch` blocks, regardless of whether an error was thrown.</li>
        <pre>
try {
  // Code that may throw an error
} catch (error) {
  console.error('Error:', error.message);
} finally {
  console.log('Cleanup code, always runs');
}
        </pre>

        <li><strong>Custom Errors:</strong> Create and throw custom error types by extending the built-in `Error` class.</li>
        <pre>
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = 'CustomError';
  }
}
throw new CustomError('This is a custom error');
        </pre>

        <li><strong>Handling Asynchronous Errors:</strong> Use `try/catch` with `async/await` for handling errors in asynchronous code.</li>
        <pre>
const fetchData = async () => {
  throw new Error('Failed to fetch data');
};
const displayData = async () => {
  try {
    const data = await fetchData();
    console.log(data);
  } catch (error) {
    console.error('Error:', error.message);
  }
};
displayData();
        </pre>

        <li><strong>Error Object Properties:</strong> Access error properties like `name`, `message`, `stack`, and custom properties for detailed error information.</li>
        <pre>
try {
  throw new Error('Example error');
} catch (error) {
  console.error('Name:', error.name);
  console.error('Message:', error.message);
  console.error('Stack:', error.stack);
}
        </pre>
    </ul>
</div>

<!-- JavaScript Closures -->
<div class="section">
    <h2>102. JavaScript Closures</h2>
    <p>Understand closures in JavaScript and how they allow functions to maintain access to their lexical scope even after execution.</p>
    <ul>
        <li><strong>Definition:</strong> A closure is a function that retains access to its lexical scope even when the function is executed outside its scope.</li>
        <pre>
const makeCounter = () => {
  let count = 0;
  return () => {
    count += 1;
    return count;
  };
};
const counter = makeCounter();
console.log(counter()); // Logs: 1
console.log(counter()); // Logs: 2
        </pre>

        <li><strong>Private Variables:</strong> Use closures to create private variables and methods that are not accessible from outside the function.</li>
        <pre>
const createPerson = (name) => {
  let age = 30; // Private variable
  return {
    getName: () => name,
    getAge: () => age,
    setAge: (newAge) => {
      age = newAge;
    }
  };
};
const person = createPerson('Alice');
console.log(person.getName()); // Logs: 'Alice'
console.log(person.getAge()); // Logs: 30
person.setAge(35);
console.log(person.getAge()); // Logs: 35
        </pre>

        <li><strong>Function Factories:</strong> Use closures to create function factories that generate functions with pre-set values or configurations.</li>
        <pre>
const createMultiplier = (multiplier) => (number) => number * multiplier;
const double = createMultiplier(2);
console.log(double(5)); // Logs: 10
const triple = createMultiplier(3);
console.log(triple(5)); // Logs: 15
        </pre>

        <li><strong>Preserving State:</strong> Use closures to preserve state between function calls without using global variables.</li>
        <pre>
const createCounter = () => {
  let count = 0;
  return {
    increment: () => count += 1,
    getCount: () => count
  };
};
const counter = createCounter();
counter.increment();
console.log(counter.getCount()); // Logs: 1
counter.increment();
console.log(counter.getCount()); // Logs: 2
        </pre>
    </ul>
</div>

<!-- JavaScript Prototypes -->
<div class="section">
    <h2>103. JavaScript Prototypes</h2>
    <p>Explore JavaScript prototypes to understand inheritance and how objects can share properties and methods.</p>
    <ul>
        <li><strong>Prototype Basics:</strong> Every JavaScript object has a `prototype` property, which allows for shared properties and methods.</li>
        <pre>
function Person(name) {
  this.name = name;
}
Person.prototype.greet = function() {
  return `Hello, my name is ${this.name}`;
};
const alice = new Person('Alice');
console.log(alice.greet()); // Logs: 'Hello, my name is Alice'
        </pre>

        <li><strong>Prototype Chain:</strong> Understand how the prototype chain works to access properties and methods from parent objects.</li>
        <pre>
function Animal(name) {
  this.name = name;
}
Animal.prototype.speak = function() {
  return `${this.name} makes a noise.`;
};

function Dog(name) {
  Animal.call(this, name);
}
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;
Dog.prototype.bark = function() {
  return `${this.name} barks.`;
};

const dog = new Dog('Rex');
console.log(dog.speak()); // Logs: 'Rex makes a noise.'
console.log(dog.bark());  // Logs: 'Rex barks.'
        </pre>

        <li><strong>Modifying Prototypes:</strong> Add or modify properties and methods on a prototype to affect all instances of an object.</li>
        <pre>
Array.prototype.first = function() {
  return this[0];
};
const numbers = [1, 2, 3];
console.log(numbers.first()); // Logs: 1
        </pre>

        <li><strong>Prototype Inheritance:</strong> Use prototype inheritance to create new types based on existing types, inheriting their properties and methods.</li>
        <pre>
function Shape() {}
Shape.prototype.area = function() {
  return 0;
};

function Rectangle(width, height) {
  this.width = width;
  this.height = height;
}
Rectangle.prototype = Object.create(Shape.prototype);
Rectangle.prototype.constructor = Rectangle;
Rectangle.prototype.area = function() {
  return this.width * this.height;
};

const rectangle = new Rectangle(5, 10);
console.log(rectangle.area()); // Logs: 50
        </pre>

        <li><strong>Object.create():</strong> Use `Object.create()` to create a new object with a specified prototype object and properties.</li>
        <pre>
const proto = {
  greet() {
    return 'Hello';
  }
};
const obj = Object.create(proto);
console.log(obj.greet()); // Logs: 'Hello'
        </pre>
    </ul>
</div>
 <!-- JavaScript Asynchronous Programming -->
<div class="section">
    <h2>104. JavaScript Asynchronous Programming</h2>
    <p>Explore asynchronous programming in JavaScript to handle operations that take time, like network requests or file reading, without blocking the main thread.</p>
    <ul>
        <li><strong>Callbacks:</strong> Use callback functions to handle asynchronous operations. A callback is a function passed into another function as an argument and executed once the operation is complete.</li>
        <pre>
function fetchData(callback) {
  setTimeout(() => {
    callback('Data received');
  }, 1000);
}
fetchData((data) => {
  console.log(data); // Logs: 'Data received'
});
        </pre>

        <li><strong>Promises:</strong> Use promises to handle asynchronous operations with a cleaner syntax and more control over success and failure states.</li>
        <pre>
const fetchData = () => {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Data received');
    }, 1000);
  });
};
fetchData().then((data) => {
  console.log(data); // Logs: 'Data received'
}).catch((error) => {
  console.error('Error:', error);
});
        </pre>

        <li><strong>Async/Await:</strong> Use `async` and `await` to write asynchronous code that looks and behaves like synchronous code. `await` pauses execution until the promise is resolved.</li>
        <pre>
const fetchData = async () => {
  return 'Data received';
};
const displayData = async () => {
  try {
    const data = await fetchData();
    console.log(data); // Logs: 'Data received'
  } catch (error) {
    console.error('Error:', error);
  }
};
displayData();
        </pre>

        <li><strong>Handling Multiple Promises:</strong> Use `Promise.all()` to handle multiple promises concurrently and `Promise.race()` to react to the first promise that resolves or rejects.</li>
        <pre>
const promise1 = new Promise((resolve) => setTimeout(() => resolve('First'), 1000));
const promise2 = new Promise((resolve) => setTimeout(() => resolve('Second'), 2000));

Promise.all([promise1, promise2]).then((results) => {
  console.log(results); // Logs: ['First', 'Second']
});

Promise.race([promise1, promise2]).then((result) => {
  console.log(result); // Logs: 'First'
});
        </pre>

        <li><strong>Async Error Handling:</strong> Handle errors in asynchronous code using `try/catch` blocks with `async/await` or `.catch()` with promises.</li>
        <pre>
const fetchData = async () => {
  throw new Error('Failed to fetch data');
};
const displayData = async () => {
  try {
    const data = await fetchData();
    console.log(data);
  } catch (error) {
    console.error('Error:', error.message);
  }
};
displayData();
        </pre>
    </ul>
</div>

<!-- JavaScript Event Handling -->
<div class="section">
    <h2>105. JavaScript Event Handling</h2>
    <p>Learn how to handle user interactions and other events in JavaScript to create dynamic and interactive web pages.</p>
    <ul>
        <li><strong>Event Listeners:</strong> Use `addEventListener()` to attach event listeners to elements. An event listener responds to specific events like clicks or keypresses.</li>
        <pre>
document.querySelector('button').addEventListener('click', () => {
  alert('Button clicked');
});
        </pre>

        <li><strong>Event Objects:</strong> Access the event object to get information about the event, such as the target element and event type.</li>
        <pre>
document.querySelector('button').addEventListener('click', (event) => {
  console.log('Event type:', event.type);
  console.log('Clicked element:', event.target);
});
        </pre>

        <li><strong>Event Delegation:</strong> Use event delegation to handle events on multiple elements using a single event listener attached to a common ancestor.</li>
        <pre>
document.querySelector('ul').addEventListener('click', (event) => {
  if (event.target.tagName === 'LI') {
    alert(`Item clicked: ${event.target.textContent}`);
  }
});
        </pre>

        <li><strong>Event Bubbling and Capturing:</strong> Understand event propagation where events bubble up from the target element to the root or capture down from the root to the target element.</li>
        <pre>
document.querySelector('div').addEventListener('click', () => {
  console.log('Div clicked - bubbling phase');
}, true); // true for capturing phase

document.querySelector('div').addEventListener('click', () => {
  console.log('Div clicked - bubbling phase');
}); // false for bubbling phase
        </pre>

        <li><strong>Removing Event Listeners:</strong> Use `removeEventListener()` to detach event listeners when they are no longer needed.</li>
        <pre>
const handleClick = () => {
  alert('Button clicked');
};
const button = document.querySelector('button');
button.addEventListener('click', handleClick);
button.removeEventListener('click', handleClick);
        </pre>

        <li><strong>Event Propagation Methods:</strong> Use methods like `stopPropagation()` to prevent further propagation of the event and `preventDefault()` to prevent the default action associated with the event.</li>
        <pre>
document.querySelector('button').addEventListener('click', (event) => {
  event.stopPropagation(); // Prevents bubbling
  event.preventDefault(); // Prevents default action
});
        </pre>
    </ul>
</div>

<!-- JavaScript DOM Manipulation -->
<div class="section">
    <h2>106. JavaScript DOM Manipulation</h2>
    <p>Manipulate the Document Object Model (DOM) to change the content, structure, and style of a web page dynamically.</p>
    <ul>
        <li><strong>Selecting Elements:</strong> Use methods like `getElementById()`, `querySelector()`, and `getElementsByClassName()` to select and interact with DOM elements.</li>
        <pre>
const elementById = document.getElementById('myId');
const elementByClass = document.getElementsByClassName('myClass')[0];
const elementByQuery = document.querySelector('.myClass');
        </pre>

        <li><strong>Modifying Content:</strong> Change the text and HTML content of elements using properties like `textContent` and `innerHTML`.</li>
        <pre>
const element = document.querySelector('#myElement');
element.textContent = 'New text content';
element.innerHTML = '<strong>New HTML content</strong>';
        </pre>

        <li><strong>Modifying Attributes:</strong> Change or retrieve the attributes of elements using methods like `setAttribute()` and `getAttribute()`.</li>
        <pre>
const element = document.querySelector('#myElement');
element.setAttribute('src', 'image.jpg');
const src = element.getAttribute('src');
console.log(src); // Logs: 'image.jpg'
        </pre>

        <li><strong>Creating and Inserting Elements:</strong> Create new elements using `createElement()` and insert them into the DOM using methods like `appendChild()` and `insertBefore()`.</li>
        <pre>
const newElement = document.createElement('div');
newElement.textContent = 'New element';
document.body.appendChild(newElement);
        </pre>

        <li><strong>Removing Elements:</strong> Remove elements from the DOM using methods like `removeChild()` and `remove()`.</li>
        <pre>
const element = document.querySelector('#myElement');
element.parentNode.removeChild(element);
// or
element.remove();
        </pre>

        <li><strong>Manipulating Classes:</strong> Add, remove, and toggle classes on elements using methods like `classList.add()`, `classList.remove()`, and `classList.toggle()`.</li>
        <pre>
const element = document.querySelector('#myElement');
element.classList.add('new-class');
element.classList.remove('old-class');
element.classList.toggle('active');
        </pre>

        <li><strong>Styling Elements:</strong> Change the inline style of elements using the `style` property.</li>
        <pre>
const element = document.querySelector('#myElement');
element.style.backgroundColor = 'blue';
element.style.color = 'white';
        </pre>

        <li><strong>Event Handling:</strong> Attach event listeners to elements to respond to user interactions or other events.</li>
        <pre>
document.querySelector('button').addEventListener('click', () => {
  alert('Button clicked');
});
        </pre>
    </ul>
</div>
<!-- JavaScript Forms and Validation -->
<div class="section">
    <h2>107. JavaScript Forms and Validation</h2>
    <p>Learn how to handle forms and validate user inputs to ensure that data submitted through web forms is accurate and complete.</p>
    <ul>
        <li><strong>Form Submission:</strong> Use the `submit` event to handle form submissions and prevent the default form submission behavior using `event.preventDefault()`.</li>
        <pre>
document.querySelector('form').addEventListener('submit', (event) => {
  event.preventDefault(); // Prevents the form from being submitted
  console.log('Form submitted');
});
        </pre>

        <li><strong>Accessing Form Data:</strong> Retrieve form values using properties like `value` and methods like `FormData` to handle form inputs programmatically.</li>
        <pre>
const form = document.querySelector('form');
const formData = new FormData(form);
console.log(formData.get('username')); // Logs the value of the 'username' input
        </pre>

        <li><strong>Form Validation:</strong> Use HTML5 validation attributes like `required`, `pattern`, and `minlength` to validate form inputs, and handle custom validation using JavaScript.</li>
        <pre>
document.querySelector('form').addEventListener('submit', (event) => {
  const username = document.querySelector('#username').value;
  if (username.length < 3) {
    alert('Username must be at least 3 characters long');
    event.preventDefault(); // Prevents the form from being submitted
  }
});
        </pre>

        <li><strong>Custom Validation Messages:</strong> Set custom validation messages using the `setCustomValidity()` method to provide user-friendly feedback.</li>
        <pre>
const input = document.querySelector('#username');
input.addEventListener('input', () => {
  if (input.value.length < 3) {
    input.setCustomValidity('Username must be at least 3 characters long');
  } else {
    input.setCustomValidity('');
  }
});
        </pre>

        <li><strong>Form Reset:</strong> Reset form fields using the `reset()` method or manually clear individual fields.</li>
        <pre>
document.querySelector('form').reset(); // Resets all form fields to their default values
        </pre>

        <li><strong>Form Data Serialization:</strong> Serialize form data into a query string or JSON format for easy submission via AJAX.</li>
        <pre>
const form = document.querySelector('form');
const formData = new FormData(form);
const serializedData = new URLSearchParams(formData).toString();
console.log(serializedData); // Logs the serialized form data
        </pre>
    </ul>
</div>

<!-- JavaScript AJAX (Asynchronous JavaScript and XML) -->
<div class="section">
    <h2>108. JavaScript AJAX (Asynchronous JavaScript and XML)</h2>
    <p>Learn how to use AJAX to fetch and send data asynchronously to and from a server without reloading the web page.</p>
    <ul>
        <li><strong>Creating an XMLHttpRequest:</strong> Use the `XMLHttpRequest` object to send and receive data from a server asynchronously.</li>
        <pre>
const xhr = new XMLHttpRequest();
xhr.open('GET', 'data.json', true);
xhr.onload = () => {
  if (xhr.status === 200) {
    console.log(xhr.responseText); // Logs the response from the server
  }
};
xhr.send();
        </pre>

        <li><strong>Handling AJAX Responses:</strong> Handle server responses using the `onload` event and check for successful status codes.</li>
        <pre>
xhr.onload = () => {
  if (xhr.status === 200) {
    const data = JSON.parse(xhr.responseText);
    console.log(data);
  } else {
    console.error('Request failed with status:', xhr.status);
  }
};
        </pre>

        <li><strong>Sending Data with AJAX:</strong> Send data to the server using the `send()` method with POST requests.</li>
        <pre>
const xhr = new XMLHttpRequest();
xhr.open('POST', 'submit.php', true);
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('name=John&age=30');
        </pre>

        <li><strong>Using Fetch API:</strong> Use the Fetch API for a more modern approach to making HTTP requests with promises.</li>
        <pre>
fetch('data.json')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Sending POST Requests with Fetch:</strong> Use the `fetch()` method to send POST requests with JSON data.</li>
        <pre>
fetch('submit.php', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ name: 'John', age: 30 })
})
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Handling Errors:</strong> Handle errors in AJAX requests using `catch()` with the Fetch API or by checking the status code with `XMLHttpRequest`.</li>
        <pre>
fetch('data.json')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>
    </ul>
</div>

<!-- JavaScript Local Storage and Cookies -->
<div class="section">
    <h2>109. JavaScript Local Storage and Cookies</h2>
    <p>Understand how to use Local Storage and Cookies to store data on the client side and manage user sessions and preferences.</p>
    <ul>
        <li><strong>Local Storage:</strong> Use `localStorage` to store data persistently in the browser, which remains even after the page is closed.</li>
        <pre>
localStorage.setItem('username', 'John');
const username = localStorage.getItem('username');
console.log(username); // Logs: 'John'
        </pre>

        <li><strong>Session Storage:</strong> Use `sessionStorage` to store data for the duration of the page session, which is cleared when the page session ends.</li>
        <pre>
sessionStorage.setItem('sessionData', 'This is session data');
const sessionData = sessionStorage.getItem('sessionData');
console.log(sessionData); // Logs: 'This is session data'
        </pre>

        <li><strong>Removing Data:</strong> Remove items from Local Storage or Session Storage using `removeItem()` or clear all data using `clear()`.</li>
        <pre>
localStorage.removeItem('username');
sessionStorage.clear();
        </pre>

        <li><strong>Cookies:</strong> Use `document.cookie` to create, read, and delete cookies. Cookies can store small amounts of data and have expiration dates.</li>
        <pre>
document.cookie = 'username=John; expires=Fri, 31 Dec 2024 23:59:59 GMT';
console.log(document.cookie); // Logs: 'username=John'
        </pre>

        <li><strong>Parsing Cookies:</strong> Parse cookies to retrieve specific values and handle multiple cookies.</li>
        <pre>
const getCookie = (name) => {
  const value = `; ${document.cookie}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) return parts.pop().split(';').shift();
};
console.log(getCookie('username')); // Logs: 'John'
        </pre>

        <li><strong>Cookie Expiration:</strong> Set cookie expiration dates using the `expires` attribute and manage cookie lifetime.</li>
        <pre>
document.cookie = 'username=John; expires=Fri, 31 Dec 2024 23:59:59 GMT';
        </pre>
    </ul>
</div>
<!-- JavaScript Error Handling -->
<div class="section">
    <h2>110. JavaScript Error Handling</h2>
    <p>Learn how to handle errors in JavaScript to ensure that your code can gracefully handle unexpected situations and provide useful feedback.</p>
    <ul>
        <li><strong>Try-Catch Statement:</strong> Use the `try-catch` statement to catch and handle exceptions that occur during code execution.</li>
        <pre>
try {
  // Code that may throw an error
  let result = riskyOperation();
} catch (error) {
  // Code to handle the error
  console.error('An error occurred:', error.message);
}
        </pre>

        <li><strong>Throwing Errors:</strong> Use the `throw` statement to manually throw an error when a certain condition is met.</li>
        <pre>
function validateAge(age) {
  if (age < 18) {
    throw new Error('Age must be 18 or older');
  }
}
try {
  validateAge(16);
} catch (error) {
  console.error('Validation error:', error.message);
}
        </pre>

        <li><strong>Custom Error Types:</strong> Create custom error types by extending the `Error` class to provide more specific error handling.</li>
        <pre>
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
  }
}

function validateInput(input) {
  if (!input) {
    throw new ValidationError('Input cannot be empty');
  }
}

try {
  validateInput('');
} catch (error) {
  if (error instanceof ValidationError) {
    console.error('Validation error:', error.message);
  } else {
    console.error('Unexpected error:', error.message);
  }
}
        </pre>

        <li><strong>Finally Block:</strong> Use the `finally` block to execute code regardless of whether an error occurred or not.</li>
        <pre>
try {
  let result = riskyOperation();
} catch (error) {
  console.error('An error occurred:', error.message);
} finally {
  console.log('This will always be executed');
}
        </pre>

        <li><strong>Asynchronous Error Handling:</strong> Handle errors in asynchronous code using `try-catch` within `async` functions or `.catch()` for promises.</li>
        <pre>
async function fetchData() {
  try {
    let response = await fetch('data.json');
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Fetch error:', error.message);
  }
}

fetchData();
        </pre>

        <li><strong>Global Error Handling:</strong> Handle global errors using the `window.onerror` event or `window.addEventListener('error', ...)` for catching unhandled exceptions.</li>
        <pre>
window.addEventListener('error', (event) => {
  console.error('Global error caught:', event.message);
});
        </pre>
    </ul>
</div>

<!-- JavaScript Promises -->
<div class="section">
    <h2>111. JavaScript Promises</h2>
    <p>Understand how to use promises to handle asynchronous operations and manage their results or errors more effectively.</p>
    <ul>
        <li><strong>Creating Promises:</strong> Create a promise using the `Promise` constructor, which represents the eventual completion (or failure) of an asynchronous operation.</li>
        <pre>
let myPromise = new Promise((resolve, reject) => {
  let success = true;
  if (success) {
    resolve('Operation was successful');
  } else {
    reject('Operation failed');
  }
});
        </pre>

        <li><strong>Consuming Promises:</strong> Use `.then()` to handle the promise's resolved value and `.catch()` to handle any errors.</li>
        <pre>
myPromise
  .then(result => console.log(result)) // Logs: 'Operation was successful'
  .catch(error => console.error(error)); // Logs error if any
        </pre>

        <li><strong>Chaining Promises:</strong> Chain multiple `.then()` calls to handle sequential asynchronous operations.</li>
        <pre>
myPromise
  .then(result => {
    console.log(result);
    return 'Next operation';
  })
  .then(nextResult => console.log(nextResult))
  .catch(error => console.error(error));
        </pre>

        <li><strong>Promise.all:</strong> Use `Promise.all()` to execute multiple promises concurrently and wait for all of them to complete.</li>
        <pre>
let promise1 = Promise.resolve('First');
let promise2 = Promise.resolve('Second');
Promise.all([promise1, promise2])
  .then(results => console.log(results)) // Logs: ['First', 'Second']
  .catch(error => console.error(error));
        </pre>

        <li><strong>Promise.race:</strong> Use `Promise.race()` to execute multiple promises and return the result of the first promise that completes.</li>
        <pre>
let promise1 = new Promise((resolve, reject) => setTimeout(resolve, 500, 'First'));
let promise2 = new Promise((resolve, reject) => setTimeout(resolve, 100, 'Second'));
Promise.race([promise1, promise2])
  .then(result => console.log(result)) // Logs: 'Second'
  .catch(error => console.error(error));
        </pre>

        <li><strong>Promise.finally:</strong> Use `.finally()` to execute code regardless of whether the promise was resolved or rejected.</li>
        <pre>
myPromise
  .then(result => console.log(result))
  .catch(error => console.error(error))
  .finally(() => console.log('Operation complete'));
        </pre>
    </ul>
</div>

<!-- JavaScript Async/Await -->
<div class="section">
    <h2>112. JavaScript Async/Await</h2>
    <p>Learn how to use `async` and `await` to simplify the syntax for working with promises and handle asynchronous code more intuitively.</p>
    <ul>
        <li><strong>Async Functions:</strong> Define an `async` function to enable the use of `await` within the function.</li>
        <pre>
async function fetchData() {
  let response = await fetch('data.json');
  let data = await response.json();
  console.log(data);
}
fetchData();
        </pre>

        <li><strong>Await Operator:</strong> Use the `await` operator to wait for a promise to resolve and return its result.</li>
        <pre>
async function getResult() {
  let result = await myPromise;
  console.log(result);
}
getResult();
        </pre>

        <li><strong>Error Handling with Async/Await:</strong> Use `try-catch` blocks within `async` functions to handle errors from asynchronous operations.</li>
        <pre>
async function fetchData() {
  try {
    let response = await fetch('data.json');
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Fetch error:', error.message);
  }
}
fetchData();
        </pre>

        <li><strong>Combining Async/Await with Other Promises:</strong> Use `async/await` in conjunction with other promise-based operations to manage complex asynchronous workflows.</li>
        <pre>
async function processData() {
  let data = await fetchData();
  let processedData = await processData(data);
  console.log(processedData);
}
processData();
        </pre>
    </ul>
</div>

<!-- JavaScript Modules -->
<div class="section">
    <h2>113. JavaScript Modules</h2>
    <p>Understand how to use JavaScript modules to organize and manage code by splitting it into reusable, modular pieces.</p>
    <ul>
        <li><strong>Exporting Modules:</strong> Use `export` to expose functions, objects, or values from a module.</li>
        <pre>
// math.js
export function add(a, b) {
  return a + b;
}
export const pi = 3.14;
        </pre>

        <li><strong>Importing Modules:</strong> Use `import` to include exported elements from other modules into your code.</li>
        <pre>
// app.js
import { add, pi } from './math.js';
console.log(add(2, 3)); // Logs: 5
console.log(pi); // Logs: 3.14
        </pre>

        <li><strong>Default Exports:</strong> Use `export default` to export a single value or function as the default export of a module.</li>
        <pre>
// utils.js
export default function greet(name) {
  return `Hello, ${name}`;
}
        </pre>
        <pre>
// app.js
import greet from './utils.js';
console.log(greet('Alice')); // Logs: 'Hello, Alice'
        </pre>

        <li><strong>Module Aliases:</strong> Use aliases when importing modules to simplify the import paths and avoid naming conflicts.</li>
        <pre>
// app.js
import * as utils from './utils.js';
console.log(utils.greet('Alice')); // Logs: 'Hello, Alice'
        </pre>

        <li><strong>Dynamic Imports:</strong> Use `import()` to load modules dynamically and asynchronously at runtime.</li>
        <pre>
async function loadModule() {
  const module = await import('./dynamicModule.js');
  module.someFunction();
}
loadModule();
        </pre>

        <li><strong>Module Scope:</strong> Understand that variables and functions within a module are scoped to that module and not accessible globally.</li>
        <pre>
// module.js
const privateVar = 'This is private';
export function getPrivateVar() {
  return privateVar;
}
        </pre>
    </ul>
</div>

<!-- JavaScript Closures -->
<div class="section">
    <h2>114. JavaScript Closures</h2>
    <p>Explore closures in JavaScript to understand how functions can retain access to their lexical scope even after they have finished executing.</p>
    <ul>
        <li><strong>Understanding Closures:</strong> A closure is a function that retains access to its lexical scope even after the function has finished executing.</li>
        <pre>
function createCounter() {
  let count = 0;
  return function() {
    count++;
    return count;
  };
}
const counter = createCounter();
console.log(counter()); // Logs: 1
console.log(counter()); // Logs: 2
        </pre>

        <li><strong>Using Closures for Data Encapsulation:</strong> Use closures to create private variables and methods that are not accessible from outside the function.</li>
        <pre>
function createPerson(name) {
  let age = 0;
  return {
    getName: function() {
      return name;
    },
    getAge: function() {
      return age;
    },
    setAge: function(newAge) {
      age = newAge;
    }
  };
}
const person = createPerson('John');
console.log(person.getName()); // Logs: 'John'
console.log(person.getAge()); // Logs: 0
person.setAge(30);
console.log(person.getAge()); // Logs: 30
        </pre>

        <li><strong>Closures and Callbacks:</strong> Use closures to preserve state in callback functions.</li>
        <pre>
function fetchData(callback) {
  let data = 'data from server';
  setTimeout(() => {
    callback(data);
  }, 1000);
}
fetchData((data) => {
  console.log('Received:', data);
});
        </pre>

        <li><strong>Memory Management with Closures:</strong> Be mindful of potential memory leaks due to closures retaining references to variables.</li>
    </ul>
</div>
<!-- JavaScript DOM Manipulation -->
<div class="section">
    <h2>115. JavaScript DOM Manipulation</h2>
    <p>Learn how to interact with and manipulate the Document Object Model (DOM) to dynamically change the content and structure of web pages.</p>
    <ul>
        <li><strong>Selecting Elements:</strong> Use methods like `getElementById`, `getElementsByClassName`, `getElementsByTagName`, and `querySelector` to select DOM elements.</li>
        <pre>
let elementById = document.getElementById('myId');
let elementsByClass = document.getElementsByClassName('myClass');
let elementsByTag = document.getElementsByTagName('div');
let singleElement = document.querySelector('.myClass');
        </pre>

        <li><strong>Modifying Content:</strong> Change the text or HTML content of selected elements using properties like `innerText` and `innerHTML`.</li>
        <pre>
let element = document.querySelector('#myElement');
element.innerText = 'New Text';
element.innerHTML = '<strong>Bold Text</strong>';
        </pre>

        <li><strong>Changing Attributes:</strong> Use methods like `setAttribute`, `getAttribute`, and `removeAttribute` to modify or retrieve attributes of elements.</li>
        <pre>
let imgElement = document.querySelector('img');
imgElement.setAttribute('src', 'newImage.jpg');
let src = imgElement.getAttribute('src');
imgElement.removeAttribute('alt');
        </pre>

        <li><strong>Creating and Inserting Elements:</strong> Create new elements using `document.createElement`, and insert them into the DOM using methods like `appendChild` and `insertBefore`.</li>
        <pre>
let newDiv = document.createElement('div');
newDiv.innerText = 'Hello, world!';
document.body.appendChild(newDiv);
        </pre>

        <li><strong>Removing Elements:</strong> Remove elements from the DOM using methods like `removeChild` and `remove`.</li>
        <pre>
let elementToRemove = document.querySelector('.removeMe');
elementToRemove.parentNode.removeChild(elementToRemove);
        </pre>

        <li><strong>Event Handling:</strong> Attach event listeners to elements using methods like `addEventListener` to handle user interactions.</li>
        <pre>
let button = document.querySelector('button');
button.addEventListener('click', () => {
  alert('Button clicked!');
});
        </pre>

        <li><strong>Event Delegation:</strong> Use event delegation to handle events on multiple elements using a single event listener.</li>
        <pre>
document.body.addEventListener('click', (event) => {
  if (event.target.matches('button')) {
    alert('Button clicked!');
  }
});
        </pre>
    </ul>
</div>

<!-- JavaScript AJAX -->
<div class="section">
    <h2>116. JavaScript AJAX</h2>
    <p>Learn how to use AJAX (Asynchronous JavaScript and XML) to make asynchronous requests to the server and update web pages dynamically.</p>
    <ul>
        <li><strong>Making AJAX Requests:</strong> Use `XMLHttpRequest` or the `fetch` API to make asynchronous HTTP requests to the server.</li>
        <pre>
let xhr = new XMLHttpRequest();
xhr.open('GET', 'data.json', true);
xhr.onload = function() {
  if (xhr.status === 200) {
    console.log(xhr.responseText);
  }
};
xhr.send();
        </pre>
        <pre>
fetch('data.json')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Handling Responses:</strong> Process server responses and update the DOM based on the received data.</li>
        <pre>
fetch('data.json')
  .then(response => response.json())
  .then(data => {
    let content = document.querySelector('#content');
    content.innerHTML = `<p>${data.message}</p>`;
  })
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Sending Data to the Server:</strong> Use `POST` requests to send data to the server and handle server responses.</li>
        <pre>
fetch('submitForm', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ key: 'value' })
})
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Handling Errors:</strong> Implement error handling for AJAX requests to manage network issues or server errors.</li>
        <pre>
fetch('data.json')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>
    </ul>
</div>

<!-- JavaScript Fetch API -->
<div class="section">
    <h2>117. JavaScript Fetch API</h2>
    <p>Explore the Fetch API to make network requests and handle responses more easily compared to the traditional `XMLHttpRequest`.</p>
    <ul>
        <li><strong>Basic Fetch Request:</strong> Use `fetch` to make a network request and handle the response.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Fetch with Options:</strong> Pass options to `fetch` for custom HTTP methods, headers, and request bodies.</li>
        <pre>
fetch('https://api.example.com/submit', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ key: 'value' })
})
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Handling JSON Responses:</strong> Convert response data to JSON format using the `.json()` method.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log(data);
  })
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Handling Non-JSON Responses:</strong> Handle responses that are not in JSON format using methods like `.text()` or `.blob()`.</li>
        <pre>
fetch('https://api.example.com/text')
  .then(response => response.text())
  .then(text => {
    console.log(text);
  })
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Abort Requests:</strong> Use the `AbortController` to cancel a fetch request if needed.</li>
        <pre>
const controller = new AbortController();
const signal = controller.signal;

fetch('https://api.example.com/data', { signal })
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('Fetch aborted');
    } else {
      console.error('Error:', error);
    }
  });

// To abort the request
controller.abort();
        </pre>
    </ul>
</div>

<!-- JavaScript Event Loop -->
<div class="section">
    <h2>118. JavaScript Event Loop</h2>
    <p>Understand how the JavaScript event loop manages asynchronous code execution and handles events.</p>
    <ul>
        <li><strong>Event Loop Overview:</strong> The event loop is a mechanism that allows JavaScript to perform non-blocking operations by executing code, handling events, and processing messages from the message queue.</li>
        <pre>
console.log('Start');

setTimeout(() => {
  console.log('Timeout callback');
}, 0);

console.log('End');
        </pre>

        <li><strong>Microtasks vs. Macrotasks:</strong> Distinguish between microtasks (e.g., promises) and macrotasks (e.g., `setTimeout`) and understand their execution order.</li>
        <pre>
console.log('Start');

Promise.resolve().then(() => {
  console.log('Promise callback');
});

setTimeout(() => {
  console.log('Timeout callback');
}, 0);

console.log('End');
        </pre>

        <li><strong>Call Stack and Callback Queue:</strong> The call stack stores function calls, and the callback queue stores callbacks and tasks to be executed after the current execution context is cleared.</li>
        <pre>
function task() {
  console.log('Task executed');
}

function executeTask() {
  console.log('Task scheduled');
  setTimeout(task, 0);
}

executeTask();
        </pre>

        <li><strong>Async Code Execution:</strong> Learn how asynchronous code (e.g., `setTimeout`, `fetch`) interacts with the event loop.</li>
        <pre>
console.log('Start');

setTimeout(() => {
  console.log('Timeout callback');
}, 1000);

fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log('Fetch callback'));

console.log('End');
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling -->
<div class="section">
    <h2>119. JavaScript Error Handling</h2>
    <p>Learn how to handle and manage errors in JavaScript to ensure smooth application execution and debugging.</p>
    <ul>
        <li><strong>Try-Catch-Finally:</strong> Use the `try`, `catch`, and `finally` statements to handle exceptions and ensure code execution regardless of errors.</li>
        <pre>
try {
  let result = riskyFunction();
} catch (error) {
  console.error('An error occurred:', error);
} finally {
  console.log('This will run regardless of error');
}
        </pre>

        <li><strong>Throwing Errors:</strong> Use the `throw` statement to create and throw custom errors.</li>
        <pre>
function validateNumber(num) {
  if (typeof num !== 'number') {
    throw new Error('Invalid number');
  }
  return num;
}
try {
  validateNumber('string');
} catch (error) {
  console.error(error.message);
}
        </pre>

        <li><strong>Handling Asynchronous Errors:</strong> Manage errors in asynchronous code (e.g., promises, async/await) using `catch` blocks or `try/catch` statements.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .catch(error => console.error('Fetch error:', error));

async function fetchData() {
  try {
    let response = await fetch('https://api.example.com/data');
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Async error:', error);
  }
}
fetchData();
        </pre>

        <li><strong>Custom Error Types:</strong> Create custom error types by extending the `Error` class for more specific error handling.</li>
        <pre>
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = 'CustomError';
  }
}
throw new CustomError('Something went wrong');
        </pre>
    </ul>
</div>
<!-- JavaScript Promises -->
<div class="section">
    <h2>120. JavaScript Promises</h2>
    <p>Understand how promises work in JavaScript for managing asynchronous operations and chaining tasks.</p>
    <ul>
        <li><strong>Creating Promises:</strong> Learn how to create promises using the `Promise` constructor and handle asynchronous tasks.</li>
        <pre>
let myPromise = new Promise((resolve, reject) => {
  let success = true; // Simulate success or failure
  if (success) {
    resolve('Success!');
  } else {
    reject('Error occurred');
  }
});
        </pre>

        <li><strong>Handling Promises:</strong> Use `then` and `catch` methods to handle promise fulfillment and rejection.</li>
        <pre>
myPromise
  .then(result => console.log(result))
  .catch(error => console.error(error));
        </pre>

        <li><strong>Promise Chaining:</strong> Chain multiple `then` methods to perform sequential asynchronous operations.</li>
        <pre>
myPromise
  .then(result => {
    console.log(result);
    return 'Next step';
  })
  .then(nextResult => console.log(nextResult))
  .catch(error => console.error(error));
        </pre>

        <li><strong>Promise.all:</strong> Use `Promise.all` to handle multiple promises and execute code once all promises are resolved.</li>
        <pre>
let promise1 = Promise.resolve('First');
let promise2 = Promise.resolve('Second');

Promise.all([promise1, promise2])
  .then(results => console.log(results)) // ['First', 'Second']
  .catch(error => console.error(error));
        </pre>

        <li><strong>Promise.race:</strong> Use `Promise.race` to get the result of the first promise that resolves or rejects.</li>
        <pre>
let promise1 = new Promise((resolve, reject) => setTimeout(resolve, 500, 'First'));
let promise2 = new Promise((resolve, reject) => setTimeout(resolve, 100, 'Second'));

Promise.race([promise1, promise2])
  .then(result => console.log(result)) // 'Second'
  .catch(error => console.error(error));
        </pre>

        <li><strong>Promise.allSettled:</strong> Use `Promise.allSettled` to get the results of all promises, regardless of their outcome.</li>
        <pre>
let promise1 = Promise.resolve('First');
let promise2 = Promise.reject('Second');

Promise.allSettled([promise1, promise2])
  .then(results => console.log(results))
  .catch(error => console.error(error));
        </pre>
    </ul>
</div>

<!-- JavaScript Async/Await -->
<div class="section">
    <h2>121. JavaScript Async/Await</h2>
    <p>Learn how to use `async` and `await` for writing asynchronous code in a more readable and synchronous style.</p>
    <ul>
        <li><strong>Declaring Async Functions:</strong> Define an `async` function that returns a promise and allows the use of `await` within it.</li>
        <pre>
async function fetchData() {
  return 'Data fetched';
}
fetchData().then(data => console.log(data));
        </pre>

        <li><strong>Using Await:</strong> Use `await` to pause execution of an `async` function until the promise is resolved.</li>
        <pre>
async function getData() {
  let response = await fetch('https://api.example.com/data');
  let data = await response.json();
  return data;
}
getData().then(data => console.log(data));
        </pre>

        <li><strong>Error Handling with Async/Await:</strong> Handle errors in `async` functions using `try` and `catch` blocks.</li>
        <pre>
async function fetchData() {
  try {
    let response = await fetch('https://api.example.com/data');
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}
fetchData();
        </pre>

        <li><strong>Combining Async/Await with Promises:</strong> Use `async` functions with `Promise.all` and other promise methods for complex scenarios.</li>
        <pre>
async function fetchAllData() {
  let promise1 = fetch('https://api.example.com/data1').then(response => response.json());
  let promise2 = fetch('https://api.example.com/data2').then(response => response.json());

  let [data1, data2] = await Promise.all([promise1, promise2]);
  console.log(data1, data2);
}
fetchAllData();
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling -->
<div class="section">
    <h2>122. JavaScript Error Handling</h2>
    <p>Learn how to handle and manage errors in JavaScript to ensure smooth application execution and debugging.</p>
    <ul>
        <li><strong>Try-Catch-Finally:</strong> Use the `try`, `catch`, and `finally` statements to handle exceptions and ensure code execution regardless of errors.</li>
        <pre>
try {
  let result = riskyFunction();
} catch (error) {
  console.error('An error occurred:', error);
} finally {
  console.log('This will run regardless of error');
}
        </pre>

        <li><strong>Throwing Errors:</strong> Use the `throw` statement to create and throw custom errors.</li>
        <pre>
function validateNumber(num) {
  if (typeof num !== 'number') {
    throw new Error('Invalid number');
  }
  return num;
}
try {
  validateNumber('string');
} catch (error) {
  console.error(error.message);
}
        </pre>

        <li><strong>Handling Asynchronous Errors:</strong> Manage errors in asynchronous code (e.g., promises, async/await) using `catch` blocks or `try/catch` statements.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .catch(error => console.error('Fetch error:', error));

async function fetchData() {
  try {
    let response = await fetch('https://api.example.com/data');
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Async error:', error);
  }
}
fetchData();
        </pre>

        <li><strong>Custom Error Types:</strong> Create custom error types by extending the `Error` class for more specific error handling.</li>
        <pre>
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = 'CustomError';
  }
}
throw new CustomError('Something went wrong');
        </pre>
    </ul>
</div>

<!-- JavaScript Modules -->
<div class="section">
    <h2>123. JavaScript Modules</h2>
    <p>Understand how to use JavaScript modules to organize and manage code in a modular way.</p>
    <ul>
        <li><strong>Exporting Modules:</strong> Use `export` to make functions, objects, or values available to other modules.</li>
        <pre>
export function greet(name) {
  return `Hello, ${name}!`;
}
export const pi = 3.14;
        </pre>

        <li><strong>Importing Modules:</strong> Use `import` to bring in exported functions, objects, or values from other modules.</li>
        <pre>
import { greet, pi } from './myModule.js';

console.log(greet('Alice'));
console.log(pi);
        </pre>

        <li><strong>Default Exports:</strong> Use `export default` to export a single value or function as the default export of a module.</li>
        <pre>
export default function greet(name) {
  return `Hello, ${name}!`;
}
        </pre>
        <pre>
import greet from './myModule.js';

console.log(greet('Alice'));
        </pre>

        <li><strong>Dynamic Imports:</strong> Use dynamic `import()` to load modules asynchronously when needed.</li>
        <pre>
async function loadModule() {
  const module = await import('./myModule.js');
  console.log(module.greet('Alice'));
}
loadModule();
        </pre>

        <li><strong>Module Paths:</strong> Understand how to set and use module paths and resolve module locations correctly.</li>
        <pre>
import { myFunction } from './path/to/module.js';
        </pre>
    </ul>
</div>
<!-- JavaScript DOM Manipulation -->
<div class="section">
    <h2>124. JavaScript DOM Manipulation</h2>
    <p>Learn how to manipulate the DOM to dynamically update the content and structure of web pages.</p>
    <ul>
        <li><strong>Selecting Elements:</strong> Use methods like `getElementById`, `querySelector`, and `querySelectorAll` to select and interact with DOM elements.</li>
        <pre>
let element = document.getElementById('myId');
let elements = document.querySelectorAll('.myClass');
        </pre>

        <li><strong>Modifying Element Content:</strong> Change the content of elements using properties like `innerHTML`, `textContent`, and `innerText`.</li>
        <pre>
let paragraph = document.querySelector('p');
paragraph.innerHTML = 'New content';
        </pre>

        <li><strong>Creating and Inserting Elements:</strong> Create new elements with `document.createElement` and insert them into the DOM using methods like `appendChild`, `insertBefore`, and `replaceChild`.</li>
        <pre>
let newDiv = document.createElement('div');
newDiv.textContent = 'Hello, world!';
document.body.appendChild(newDiv);
        </pre>

        <li><strong>Removing Elements:</strong> Remove elements from the DOM using the `remove` method or `parentNode.removeChild`.</li>
        <pre>
let elementToRemove = document.getElementById('removeMe');
elementToRemove.remove(); // or
document.body.removeChild(elementToRemove);
        </pre>

        <li><strong>Modifying Element Attributes:</strong> Use `setAttribute`, `getAttribute`, and `removeAttribute` to manage element attributes.</li>
        <pre>
let link = document.querySelector('a');
link.setAttribute('href', 'https://new-url.com');
let href = link.getAttribute('href');
link.removeAttribute('href');
        </pre>

        <li><strong>Event Handling:</strong> Attach event listeners to elements using methods like `addEventListener` to respond to user interactions.</li>
        <pre>
let button = document.querySelector('button');
button.addEventListener('click', () => {
  alert('Button clicked!');
});
        </pre>

        <li><strong>Event Delegation:</strong> Use event delegation to manage events on dynamically added elements by attaching event listeners to a parent element.</li>
        <pre>
document.body.addEventListener('click', (event) => {
  if (event.target.matches('button')) {
    alert('Button clicked!');
  }
});
        </pre>
    </ul>
</div>

<!-- JavaScript Animation -->
<div class="section">
    <h2>125. JavaScript Animation</h2>
    <p>Explore how to create animations and transitions to enhance the visual appeal of web pages.</p>
    <ul>
        <li><strong>Using setInterval and setTimeout:</strong> Create simple animations by repeatedly executing code at intervals using `setInterval` and `setTimeout`.</li>
        <pre>
let box = document.getElementById('box');
let position = 0;
function animate() {
  position += 1;
  box.style.left = position + 'px';
  if (position < 200) {
    setTimeout(animate, 10);
  }
}
animate();
        </pre>

        <li><strong>CSS Animations:</strong> Use CSS animations with JavaScript by applying CSS classes that define keyframe animations.</li>
        <pre>
let box = document.getElementById('box');
box.classList.add('animate');
        </pre>
        <style>
        .animate {
            animation: move 2s infinite;
        }
        @keyframes move {
            0% { transform: translateX(0); }
            100% { transform: translateX(100px); }
        }
        </style>

        <li><strong>CSS Transitions:</strong> Manage transitions between CSS property values using JavaScript to trigger changes.</li>
        <pre>
let box = document.getElementById('box');
box.style.transition = 'transform 0.5s';
box.style.transform = 'translateX(100px)';
        </pre>

        <li><strong>Request Animation Frame:</strong> Use `requestAnimationFrame` for smooth, optimized animations by synchronizing with the browsers refresh rate.</li>
        <pre>
let box = document.getElementById('box');
let position = 0;
function animate() {
  position += 1;
  box.style.transform = `translateX(${position}px)`;
  if (position < 200) {
    requestAnimationFrame(animate);
  }
}
animate();
        </pre>
    </ul>
</div>

<!-- JavaScript Fetch API -->
<div class="section">
    <h2>126. JavaScript Fetch API</h2>
    <p>Learn how to use the Fetch API for making network requests and handling responses.</p>
    <ul>
        <li><strong>Making GET Requests:</strong> Use the `fetch` function to make HTTP GET requests and handle the response.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Making POST Requests:</strong> Send data to a server using HTTP POST requests with the `fetch` function.</li>
        <pre>
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json'
  },
  body: JSON.stringify({ key: 'value' })
})
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Handling Response Status:</strong> Check the status code of the response to handle different HTTP responses.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => {
    if (response.ok) {
      return response.json();
    }
    throw new Error('Network response was not ok.');
  })
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Abort Requests:</strong> Use `AbortController` to cancel ongoing network requests.</li>
        <pre>
let controller = new AbortController();
let signal = controller.signal;

fetch('https://api.example.com/data', { signal })
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => {
    if (error.name === 'AbortError') {
      console.log('Fetch aborted');
    } else {
      console.error('Error:', error);
    }
  });

// To abort the request
controller.abort();
        </pre>
    </ul>
</div>

<!-- JavaScript Local Storage -->
<div class="section">
    <h2>127. JavaScript Local Storage</h2>
    <p>Understand how to use localStorage and sessionStorage for storing data in the browser.</p>
    <ul>
        <li><strong>Storing Data:</strong> Use `localStorage.setItem` and `sessionStorage.setItem` to store data as key-value pairs.</li>
        <pre>
localStorage.setItem('key', 'value');
sessionStorage.setItem('key', 'value');
        </pre>

        <li><strong>Retrieving Data:</strong> Use `localStorage.getItem` and `sessionStorage.getItem` to retrieve stored data.</li>
        <pre>
let value = localStorage.getItem('key');
let sessionValue = sessionStorage.getItem('key');
console.log(value);
console.log(sessionValue);
        </pre>

        <li><strong>Removing Data:</strong> Use `localStorage.removeItem` and `sessionStorage.removeItem` to remove specific items.</li>
        <pre>
localStorage.removeItem('key');
sessionStorage.removeItem('key');
        </pre>

        <li><strong>Clearing All Data:</strong> Use `localStorage.clear` and `sessionStorage.clear` to remove all data stored in the storage.</li>
        <pre>
localStorage.clear();
sessionStorage.clear();
        </pre>

        <li><strong>Handling JSON Data:</strong> Store and retrieve JSON data by converting it to a string and parsing it.</li>
        <pre>
let obj = { name: 'Alice', age: 30 };
localStorage.setItem('user', JSON.stringify(obj));

let user = JSON.parse(localStorage.getItem('user'));
console.log(user);
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling -->
<div class="section">
    <h2>128. JavaScript Error Handling</h2>
    <p>Learn how to handle and manage errors effectively in JavaScript code.</p>
    <ul>
        <li><strong>Handling Synchronous Errors:</strong> Use `try...catch` blocks to catch and handle errors in synchronous code.</li>
        <pre>
try {
  let result = someFunction();
} catch (error) {
  console.error('Error:', error.message);
}
        </pre>

        <li><strong>Handling Asynchronous Errors:</strong> Use `catch` with promises or `try...catch` with async/await to handle errors in asynchronous operations.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .catch(error => console.error('Fetch error:', error));
        </pre>
        <pre>
async function getData() {
  try {
    let response = await fetch('https://api.example.com/data');
    let data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Async error:', error);
  }
}
getData();
        </pre>

        <li><strong>Custom Error Types:</strong> Create and throw custom error types to handle specific error conditions.</li>
        <pre>
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = 'CustomError';
  }
}

throw new CustomError('Something went wrong');
        </pre>

        <li><strong>Error Logging:</strong> Implement error logging mechanisms to capture and record errors for debugging and monitoring.</li>
        <pre>
function logError(error) {
  console.error('Logging error:', error);
  // Implement logging to server or file
}

try {
  let result = anotherFunction();
} catch (error) {
  logError(error);
}
        </pre>
    </ul>
</div>

<!-- JavaScript Closures -->
<div class="section">
    <h2>129. JavaScript Closures</h2>
    <p>Explore closures in JavaScript to understand how functions can access variables from their outer scope.</p>
    <ul>
        <li><strong>Understanding Closures:</strong> Learn how closures allow inner functions to access variables from their outer functions even after the outer function has executed.</li>
        <pre>
function outerFunction() {
  let outerVariable = 'I am from outer scope';
  
  function innerFunction() {
    console.log(outerVariable);
  }
  
  return innerFunction;
}

let closureFunction = outerFunction();
closureFunction(); // 'I am from outer scope'
        </pre>

        <li><strong>Using Closures for Data Encapsulation:</strong> Use closures to create private variables and encapsulate data within functions.</li>
        <pre>
function createCounter() {
  let count = 0;
  
  return {
    increment: function() {
      count++;
      return count;
    },
    decrement: function() {
      count--;
      return count;
    },
    getCount: function() {
      return count;
    }
  };
}

let counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.getCount()); // 1
        </pre>

        <li><strong>Practical Use Cases:</strong> Apply closures in practical scenarios such as creating factories, managing state, and implementing private methods.</li>
        <pre>
function createGreeting(name) {
  return function() {
    return `Hello, ${name}!`;
  };
}

let greetAlice = createGreeting('Alice');
console.log(greetAlice()); // 'Hello, Alice!'
        </pre>
    </ul>
</div>

<!-- JavaScript Higher-Order Functions -->
<div class="section">
    <h2>130. JavaScript Higher-Order Functions</h2>
    <p>Understand higher-order functions that take other functions as arguments or return functions as their result.</p>
    <ul>
        <li><strong>Defining Higher-Order Functions:</strong> Learn how functions can accept other functions as arguments or return functions as results.</li>
        <pre>
function higherOrderFunction(callback) {
  return function(value) {
    return callback(value);
  };
}

function double(x) {
  return x * 2;
}

let doubleFunction = higherOrderFunction(double);
console.log(doubleFunction(5)); // 10
        </pre>

        <li><strong>Function Composition:</strong> Compose multiple functions together to build complex operations.</li>
        <pre>
function compose(f, g) {
  return function(x) {
    return f(g(x));
  };
}

function square(x) {
  return x * x;
}

function double(x) {
  return x * 2;
}

let squareThenDouble = compose(double, square);
console.log(squareThenDouble(5)); // 50
        </pre>

        <li><strong>Map, Filter, and Reduce:</strong> Use built-in higher-order functions like `map`, `filter`, and `reduce` to process arrays.</li>
        <pre>
let numbers = [1, 2, 3, 4, 5];

let squares = numbers.map(x => x * x);
let evens = numbers.filter(x => x % 2 === 0);
let sum = numbers.reduce((acc, x) => acc + x, 0);

console.log(squares); // [1, 4, 9, 16, 25]
console.log(evens); // [2, 4]
console.log(sum); // 15
        </pre>

        <li><strong>Using Higher-Order Functions with Callbacks:</strong> Implement callbacks to handle asynchronous operations and event handling.</li>
        <pre>
function fetchData(callback) {
  setTimeout(() => {
    callback('Data loaded');
  }, 1000);
}

fetchData(data => console.log(data)); // 'Data loaded'
        </pre>
    </ul>
</div>
<!-- JavaScript Promises -->
<div class="section">
    <h2>131. JavaScript Promises</h2>
    <p>Learn how to use promises to handle asynchronous operations and manage asynchronous flow in JavaScript.</p>
    <ul>
        <li><strong>Understanding Promises:</strong> Understand the concept of promises, which represent the eventual completion or failure of an asynchronous operation.</li>
        <pre>
let promise = new Promise((resolve, reject) => {
  let success = true;
  if (success) {
    resolve('Operation succeeded');
  } else {
    reject('Operation failed');
  }
});

promise.then(result => console.log(result))
       .catch(error => console.error(error));
        </pre>

        <li><strong>Promise Chaining:</strong> Chain multiple `.then` methods to handle a sequence of asynchronous operations.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    console.log('Data:', data);
    return data.processed;
  })
  .then(result => console.log('Processed result:', result))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Promise.all:</strong> Use `Promise.all` to execute multiple promises in parallel and wait for all of them to complete.</li>
        <pre>
let promise1 = fetch('https://api.example.com/data1');
let promise2 = fetch('https://api.example.com/data2');

Promise.all([promise1, promise2])
  .then(responses => Promise.all(responses.map(response => response.json())))
  .then(data => console.log('All data:', data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Promise.race:</strong> Use `Promise.race` to wait for the first promise to complete among a group of promises.</li>
        <pre>
let promise1 = new Promise((resolve, reject) => setTimeout(resolve, 500, 'First'));
let promise2 = new Promise((resolve, reject) => setTimeout(resolve, 100, 'Second'));

Promise.race([promise1, promise2])
  .then(result => console.log('Race result:', result))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Promise.finally:</strong> Use `Promise.finally` to execute code after a promise is settled, regardless of its outcome.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log('Data:', data))
  .catch(error => console.error('Error:', error))
  .finally(() => console.log('Fetch operation complete'));
        </pre>
    </ul>
</div>

<!-- JavaScript Async/Await -->
<div class="section">
    <h2>132. JavaScript Async/Await</h2>
    <p>Understand how to use `async` and `await` to write asynchronous code that is easier to read and manage.</p>
    <ul>
        <li><strong>Using async Functions:</strong> Declare functions as `async` to enable the use of `await` within them.</li>
        <pre>
async function fetchData() {
  let response = await fetch('https://api.example.com/data');
  let data = await response.json();
  return data;
}

fetchData().then(data => console.log('Data:', data))
           .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Handling Errors with try...catch:</strong> Use `try...catch` blocks to handle errors in `async` functions.</li>
        <pre>
async function fetchData() {
  try {
    let response = await fetch('https://api.example.com/data');
    let data = await response.json();
    return data;
  } catch (error) {
    console.error('Error:', error);
  }
}
        </pre>

        <li><strong>Awaiting Multiple Promises:</strong> Use `await` with multiple promises to handle concurrent asynchronous operations.</li>
        <pre>
async function fetchMultipleData() {
  let [response1, response2] = await Promise.all([
    fetch('https://api.example.com/data1'),
    fetch('https://api.example.com/data2')
  ]);

  let data1 = await response1.json();
  let data2 = await response2.json();

  console.log('Data 1:', data1);
  console.log('Data 2:', data2);
}
fetchMultipleData();
        </pre>

        <li><strong>Using Async/Await with for...of Loops:</strong> Iterate over a collection of promises using `for...of` loops with `await`.</li>
        <pre>
async function processItems(items) {
  for (let item of items) {
    let result = await processItem(item);
    console.log(result);
  }
}

async function processItem(item) {
  // Simulate async processing
  return new Promise(resolve => setTimeout(() => resolve(item), 1000));
}
processItems(['item1', 'item2', 'item3']);
        </pre>
    </ul>
</div>

<!-- JavaScript Modules -->
<div class="section">
    <h2>133. JavaScript Modules</h2>
    <p>Learn how to use JavaScript modules to organize and encapsulate code in separate files.</p>
    <ul>
        <li><strong>Importing Modules:</strong> Use the `import` statement to bring in functions, objects, or values from other modules.</li>
        <pre>
import { functionName } from './module.js';
import * as module from './module.js';
        </pre>

        <li><strong>Exporting Modules:</strong> Use the `export` statement to make functions, objects, or values available for other modules to import.</li>
        <pre>
export function myFunction() {
  // function code
}

export const myValue = 42;
        </pre>

        <li><strong>Default Exports:</strong> Use `export default` to export a single value or function from a module.</li>
        <pre>
export default function myFunction() {
  // function code
}
        </pre>

        <li><strong>Dynamic Imports:</strong> Use `import()` for dynamic imports that allow loading modules on demand.</li>
        <pre>
async function loadModule() {
  let module = await import('./module.js');
  module.functionName();
}
loadModule();
        </pre>

        <li><strong>Module Path Resolution:</strong> Understand how module paths are resolved and use relative or absolute paths to import modules.</li>
        <pre>
import { myFunction } from '../utils/module.js'; // Relative path
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling in Async Code -->
<div class="section">
    <h2>134. JavaScript Error Handling in Async Code</h2>
    <p>Master error handling strategies specifically for asynchronous JavaScript operations.</p>
    <ul>
        <li><strong>Handling Errors in Promises:</strong> Use `.catch` to handle errors that occur during promise-based operations.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .catch(error => console.error('Fetch error:', error));
        </pre>

        <li><strong>Handling Errors with Async/Await:</strong> Use `try...catch` blocks to catch errors in `async` functions.</li>
        <pre>
async function fetchData() {
  try {
    let response = await fetch('https://api.example.com/data');
    let data = await response.json();
    return data;
  } catch (error) {
    console.error('Async function error:', error);
  }
}
        </pre>

        <li><strong>Custom Error Handling:</strong> Create and throw custom errors to provide more specific error information.</li>
        <pre>
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = 'CustomError';
  }
}

async function fetchData() {
  try {
    let response = await fetch('https://api.example.com/data');
    if (!response.ok) {
      throw new CustomError('Custom error message');
    }
    let data = await response.json();
    return data;
  } catch (error) {
    console.error('Custom error handling:', error);
  }
}
        </pre>

        <li><strong>Global Error Handling:</strong> Implement global error handlers to catch unhandled errors and promise rejections.</li>
        <pre>
window.addEventListener('unhandledrejection', event => {
  console.error('Unhandled rejection:', event.reason);
});

window.addEventListener('error', event => {
  console.error('Global error:', event.message);
});
        </pre>
    </ul>
</div>

<!-- JavaScript Context and Scope -->
<div class="section">
    <h2>135. JavaScript Context and Scope</h2>
    <p>Explore how context and scope affect variable access and function execution in JavaScript.</p>
    <ul>
        <li><strong>Execution Context:</strong> Understand the concept of execution context and how it affects variable and function access.</li>
        <pre>
function example() {
  console.log(this); // 'this' refers to the global object or undefined in strict mode
}
example();
        </pre>

        <li><strong>Scope Chains:</strong> Learn how scope chains work to resolve variable references in nested functions.</li>
        <pre>
function outerFunction() {
  let outerVariable = 'I am outer';
  
  function innerFunction() {
    console.log(outerVariable); // Accesses outerVariable from outerFunction
  }
  
  innerFunction();
}
outerFunction();
        </pre>

        <li><strong>Lexical Scope:</strong> Understand lexical scope and how variables are resolved based on the location of their declaration in the source code.</li>
        <pre>
let globalVar = 'I am global';

function outerFunction() {
  let outerVar = 'I am outer';
  
  function innerFunction() {
    console.log(globalVar); // 'I am global'
    console.log(outerVar);  // 'I am outer'
  }
  
  innerFunction();
}
outerFunction();
        </pre>

        <li><strong>Closures and Scope:</strong> See how closures capture and maintain scope information from their creation context.</li>
        <pre>
function createCounter() {
  let count = 0;
  
  return function() {
    count++;
    return count;
  };
}

let counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
        </pre>
    </ul>
</div>
<!-- JavaScript Closures -->
<div class="section">
    <h2>136. JavaScript Closures</h2>
    <p>Closures are an important concept in JavaScript that allow functions to access variables from their outer scope even after the outer function has finished execution.</p>
    <ul>
        <li><strong>Creating a Closure:</strong> Learn how closures are created when a function is defined within another function.</li>
        <pre>
function outerFunction() {
    let outerVariable = 'I am outer';
    
    function innerFunction() {
        console.log(outerVariable); // Accesses outerVariable from outerFunction
    }
    
    return innerFunction;
}

const myClosure = outerFunction();
myClosure(); // Logs: 'I am outer'
        </pre>

        <li><strong>Using Closures for Data Encapsulation:</strong> Use closures to encapsulate data and create private variables.</li>
        <pre>
function createCounter() {
    let count = 0;
    
    return {
        increment: function() {
            count++;
            return count;
        },
        decrement: function() {
            count--;
            return count;
        },
        getCount: function() {
            return count;
        }
    };
}

const counter = createCounter();
console.log(counter.increment()); // 1
console.log(counter.increment()); // 2
console.log(counter.getCount()); // 2
console.log(counter.decrement()); // 1
        </pre>

        <li><strong>Closures with Loops:</strong> Understand how closures work inside loops, particularly with `let` and `var`.</li>
        <pre>
function createFunctions() {
    let functions = [];
    for (let i = 0; i < 3; i++) {
        functions.push(function() {
            return i;
        });
    }
    return functions;
}

const funcs = createFunctions();
console.log(funcs[0]()); // 0
console.log(funcs[1]()); // 1
console.log(funcs[2]()); // 2
        </pre>

        <li><strong>Common Closure Pitfalls:</strong> Learn about common issues with closures, such as capturing loop variables incorrectly.</li>
        <pre>
function createFunctions() {
    let functions = [];
    for (var i = 0; i < 3; i++) {
        functions.push(function() {
            return i;
        });
    }
    return functions;
}

const funcs = createFunctions();
console.log(funcs[0]()); // 3 (not 0)
console.log(funcs[1]()); // 3 (not 1)
console.log(funcs[2]()); // 3 (not 2)
        </pre>
    </ul>
</div>

<!-- JavaScript Event Delegation -->
<div class="section">
    <h2>137. JavaScript Event Delegation</h2>
    <p>Event delegation is a technique used to handle events efficiently by attaching a single event listener to a parent element instead of individual child elements.</p>
    <ul>
        <li><strong>Understanding Event Delegation:</strong> Learn how event delegation works by attaching an event listener to a parent element that handles events for its child elements.</li>
        <pre>
document.querySelector('#parent').addEventListener('click', function(event) {
    if (event.target && event.target.matches('button')) {
        console.log('Button clicked:', event.target.textContent);
    }
});
        </pre>

        <li><strong>Benefits of Event Delegation:</strong> Understand the advantages of event delegation, such as reduced memory usage and improved performance.</li>
        <pre>
<!-- HTML Structure -->
<div id="parent">
    <button>Button 1</button>
    <button>Button 2</button>
    <button>Button 3</button>
</div>
        </pre>

        <li><strong>Event Delegation with Dynamic Content:</strong> Use event delegation to handle events for dynamically added elements.</li>
        <pre>
const parent = document.querySelector('#parent');

function addButton() {
    let button = document.createElement('button');
    button.textContent = 'New Button';
    parent.appendChild(button);
}

parent.addEventListener('click', function(event) {
    if (event.target && event.target.matches('button')) {
        console.log('Button clicked:', event.target.textContent);
    }
});

addButton(); // Adds a new button and the click event will still be handled
        </pre>

        <li><strong>Delegating Different Events:</strong> Apply event delegation for various event types, not just click events.</li>
        <pre>
document.querySelector('#parent').addEventListener('mouseover', function(event) {
    if (event.target && event.target.matches('button')) {
        console.log('Mouse over button:', event.target.textContent);
    }
});
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling -->
<div class="section">
    <h2>138. JavaScript Error Handling</h2>
    <p>Effective error handling is crucial for debugging and managing errors in JavaScript applications.</p>
    <ul>
        <li><strong>Using try...catch:</strong> Handle synchronous errors using `try...catch` blocks to prevent your application from crashing.</li>
        <pre>
try {
    let result = riskyOperation();
} catch (error) {
    console.error('Error occurred:', error);
}
        </pre>

        <li><strong>Using throw to Generate Errors:</strong> Use `throw` to create custom error messages and throw them intentionally.</li>
        <pre>
function validateNumber(num) {
    if (typeof num !== 'number') {
        throw new Error('Invalid input: Not a number');
    }
    return num;
}

try {
    validateNumber('string');
} catch (error) {
    console.error('Validation error:', error);
}
        </pre>

        <li><strong>Handling Errors in Async Functions:</strong> Use `try...catch` in `async` functions to handle errors from promises.</li>
        <pre>
async function fetchData() {
    try {
        let response = await fetch('https://api.example.com/data');
        let data = await response.json();
        return data;
    } catch (error) {
        console.error('Fetch error:', error);
    }
}
        </pre>

        <li><strong>Global Error Handlers:</strong> Implement global error handlers to catch errors that are not handled locally.</li>
        <pre>
window.addEventListener('error', function(event) {
    console.error('Global error:', event.message);
});

window.addEventListener('unhandledrejection', function(event) {
    console.error('Unhandled rejection:', event.reason);
});
        </pre>
    </ul>
</div>

<!-- JavaScript Regular Expressions -->
<div class="section">
    <h2>139. JavaScript Regular Expressions</h2>
    <p>Regular expressions (regex) provide a powerful way to perform pattern matching and text manipulation in JavaScript.</p>
    <ul>
        <li><strong>Creating Regular Expressions:</strong> Learn how to create regex patterns using literals or the `RegExp` constructor.</li>
        <pre>
let regexLiteral = /pattern/;
let regexConstructor = new RegExp('pattern');
        </pre>

        <li><strong>Basic Regex Patterns:</strong> Understand basic regex patterns and special characters.</li>
        <pre>
let pattern = /\d+/; // Matches one or more digits
let str = '123abc';
console.log(pattern.test(str)); // true
        </pre>

        <li><strong>Regex Methods:</strong> Use regex methods such as `test`, `exec`, `match`, `replace`, `search`, and `split`.</li>
        <pre>
let text = 'The quick brown fox jumps over the lazy dog.';
let result = text.match(/\b\w{5}\b/g); // Matches all 5-letter words
console.log(result); // ['quick', 'brown', 'jumps']
        </pre>

        <li><strong>Regex Flags:</strong> Utilize regex flags such as `g` (global), `i` (case-insensitive), `m` (multiline), etc.</li>
        <pre>
let pattern = /abc/i; // Case-insensitive match
let str = 'ABC';
console.log(pattern.test(str)); // true
        </pre>

        <li><strong>Regex Groups and Capturing:</strong> Learn about capturing groups and how to extract matched substrings.</li>
        <pre>
let pattern = /(\d{3})-(\d{2})-(\d{4})/;
let str = '123-45-6789';
let result = pattern.exec(str);
console.log(result); // ['123-45-6789', '123', '45', '6789']
        </pre>

        <li><strong>Using Lookahead and Lookbehind:</strong> Use lookahead and lookbehind assertions for advanced pattern matching.</li>
        <pre>
let pattern = /(?<=\d{3}-)\d{2}/; // Positive lookbehind
let str = '123-45-6789';
console.log(str.match(pattern)); // ['45']
        </pre>
    </ul>
</div>

<!-- JavaScript DOM Manipulation -->
<div class="section">
    <h2>140. JavaScript DOM Manipulation</h2>
    <p>Manipulating the Document Object Model (DOM) allows you to dynamically modify the content and structure of web pages.</p>
    <ul>
        <li><strong>Selecting Elements:</strong> Learn various methods to select DOM elements such as `querySelector`, `getElementById`, `getElementsByClassName`, and `getElementsByTagName`.</li>
        <pre>
let element = document.querySelector('#myElement');
let elements = document.getElementsByClassName('myClass');
        </pre>

        <li><strong>Modifying Content:</strong> Use properties and methods to change the content of elements, such as `innerHTML`, `textContent`, and `innerText`.</li>
        <pre>
let element = document.getElementById('myElement');
element.innerHTML = '<p>New content</p>';
        </pre>

        <li><strong>Creating and Appending Elements:</strong> Create new elements using `document.createElement` and append them to the DOM.</li>
        <pre>
let newElement = document.createElement('div');
newElement.textContent = 'This is a new element';
document.body.appendChild(newElement);
        </pre>

        <li><strong>Removing Elements:</strong> Remove elements from the DOM using methods like `removeChild` and `remove`.</li>
        <pre>
let element = document.getElementById('myElement');
element.parentNode.removeChild(element);
        </pre>

        <li><strong>Modifying Element Attributes:</strong> Change element attributes using `setAttribute`, `getAttribute`, and `removeAttribute`.</li>
        <pre>
let element = document.getElementById('myElement');
element.setAttribute('data-id', '123');
console.log(element.getAttribute('data-id')); // '123'
element.removeAttribute('data-id');
        </pre>

        <li><strong>Handling Events:</strong> Attach event listeners to elements to handle user interactions such as clicks, form submissions, and more.</li>
        <pre>
document.querySelector('#myButton').addEventListener('click', function() {
    alert('Button clicked!');
});
        </pre>
    </ul>
</div>
<!-- JavaScript Asynchronous Programming -->
<div class="section">
    <h2>141. JavaScript Asynchronous Programming</h2>
    <p>Asynchronous programming in JavaScript allows for non-blocking code execution, making it possible to handle tasks like API requests and file reading more efficiently.</p>
    <ul>
        <li><strong>Understanding Asynchronous Code:</strong> Learn the difference between synchronous and asynchronous code and how asynchronous code can improve performance.</li>
        <pre>
console.log('Start');
setTimeout(() => {
    console.log('Timeout callback');
}, 1000);
console.log('End');
// Logs: 'Start', 'End', 'Timeout callback'
        </pre>

        <li><strong>Using Callbacks:</strong> Manage asynchronous tasks using callbacks, but be aware of issues like callback hell.</li>
        <pre>
function fetchData(callback) {
    setTimeout(() => {
        callback('Data loaded');
    }, 1000);
}

fetchData(function(data) {
    console.log(data); // 'Data loaded'
});
        </pre>

        <li><strong>Promises:</strong> Use promises to handle asynchronous operations and chain multiple async operations together.</li>
        <pre>
let promise = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve('Data loaded');
    }, 1000);
});

promise.then((data) => {
    console.log(data); // 'Data loaded'
});
        </pre>

        <li><strong>Async/Await:</strong> Simplify asynchronous code using `async` and `await` to write more readable and manageable async functions.</li>
        <pre>
async function fetchData() {
    let response = await new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve('Data loaded');
        }, 1000);
    });
    console.log(response); // 'Data loaded'
}

fetchData();
        </pre>

        <li><strong>Handling Errors in Async/Await:</strong> Use `try...catch` blocks to handle errors in async functions.</li>
        <pre>
async function fetchData() {
    try {
        let response = await new Promise((resolve, reject) => {
            setTimeout(() => {
                reject('Error loading data');
            }, 1000);
        });
        console.log(response);
    } catch (error) {
        console.error(error); // 'Error loading data'
    }
}

fetchData();
        </pre>
    </ul>
</div>

<!-- JavaScript Event Loop -->
<div class="section">
    <h2>142. JavaScript Event Loop</h2>
    <p>The event loop is a core part of JavaScript's concurrency model that manages the execution of code, events, and message handling.</p>
    <ul>
        <li><strong>Understanding the Event Loop:</strong> Learn how the event loop works to handle asynchronous code, callbacks, and tasks.</li>
        <pre>
console.log('Start');
setTimeout(() => {
    console.log('Timeout callback');
}, 0);
console.log('End');
// Logs: 'Start', 'End', 'Timeout callback'
        </pre>

        <li><strong>Microtasks vs. Macrotasks:</strong> Distinguish between microtasks (e.g., promises) and macrotasks (e.g., `setTimeout`) and how they are processed in the event loop.</li>
        <pre>
console.log('Start');

Promise.resolve().then(() => {
    console.log('Microtask');
});

setTimeout(() => {
    console.log('Macrotask');
}, 0);

console.log('End');
// Logs: 'Start', 'End', 'Microtask', 'Macrotask'
        </pre>

        <li><strong>Handling Multiple Event Loops:</strong> Understand how multiple event loops can be managed in the context of Web Workers.</li>
        <pre>
if (window.Worker) {
    let worker = new Worker('worker.js');
    worker.onmessage = function(event) {
        console.log('Message from worker:', event.data);
    };
    worker.postMessage('Hello Worker');
}
        </pre>

        <li><strong>Optimizing Event Loop Performance:</strong> Learn techniques to optimize performance and avoid blocking the event loop.</li>
        <pre>
function heavyComputation() {
    for (let i = 0; i < 1e8; i++) {
        // Simulate heavy computation
    }
}

console.log('Start');
setTimeout(() => {
    heavyComputation();
    console.log('Heavy computation done');
}, 0);
console.log('End');
// Logs: 'Start', 'End', 'Heavy computation done'
        </pre>
    </ul>
</div>

<!-- JavaScript Modules -->
<div class="section">
    <h2>143. JavaScript Modules</h2>
    <p>JavaScript modules allow you to organize and encapsulate code into separate files, making it easier to manage and maintain.</p>
    <ul>
        <li><strong>Introduction to Modules:</strong> Understand the benefits of using modules for code organization and reusability.</li>
        <pre>
/* math.js */
export function add(a, b) {
    return a + b;
}

/* main.js */
import { add } from './math.js';
console.log(add(2, 3)); // 5
        </pre>

        <li><strong>Default Exports:</strong> Use default exports to export a single value or function from a module.</li>
        <pre>
/* logger.js */
export default function log(message) {
    console.log(message);
}

/* main.js */
import log from './logger.js';
log('Hello, world!'); // 'Hello, world!'
        </pre>

        <li><strong>Named Exports:</strong> Export multiple values or functions from a module using named exports.</li>
        <pre>
/* utils.js */
export function sum(a, b) {
    return a + b;
}

export function multiply(a, b) {
    return a * b;
}

/* main.js */
import { sum, multiply } from './utils.js';
console.log(sum(1, 2)); // 3
console.log(multiply(2, 3)); // 6
        </pre>

        <li><strong>Dynamic Imports:</strong> Use dynamic imports to load modules conditionally at runtime.</li>
        <pre>
async function loadModule() {
    let module = await import('./module.js');
    module.doSomething();
}

loadModule();
        </pre>

        <li><strong>Module Resolution and Bundling:</strong> Understand how modules are resolved and bundled using tools like Webpack or Rollup.</li>
        <pre>
module.exports = {
    entry: './main.js',
    output: {
        filename: 'bundle.js',
        path: __dirname + '/dist'
    },
    // Other Webpack configuration...
};
        </pre>
    </ul>
</div>
<!-- JavaScript Closures -->
<div class="section">
    <h2>144. JavaScript Closures</h2>
    <p>Closures in JavaScript are functions that "remember" the variables from their outer lexical environment, even after that environment has finished executing.</p>
    <ul>
        <li><strong>Understanding Closures:</strong> Closures allow inner functions to access variables from an outer function's scope. This enables powerful patterns for managing state and creating function factories.</li>
        <pre>
function outerFunction(outerVariable) {
    return function innerFunction(innerVariable) {
        console.log(`Outer: ${outerVariable}, Inner: ${innerVariable}`);
    };
}

const newFunction = outerFunction('outside');
newFunction('inside'); // 'Outer: outside, Inner: inside'
        </pre>

        <li><strong>Practical Uses of Closures:</strong> Closures are used in many JavaScript patterns, such as function factories, data encapsulation, and creating private variables.</li>
    </ul>
</div>

<!-- JavaScript Promises -->
<div class="section">
    <h2>145. JavaScript Promises</h2>
    <p>Promises are used to handle asynchronous operations in JavaScript. They represent a value that may be available now, or in the future, or never.</p>
    <ul>
        <li><strong>Creating Promises:</strong> Use the <code>Promise</code> constructor to create a new promise. The promise takes an executor function with <code>resolve</code> and <code>reject</code> arguments.</li>
        <pre>
const myPromise = new Promise((resolve, reject) => {
    // Asynchronous operation
    setTimeout(() => {
        resolve('Promise resolved!');
    }, 1000);
});

myPromise.then(result => console.log(result)).catch(error => console.log(error));
        </pre>

        <li><strong>Chaining Promises:</strong> Promises can be chained using the <code>.then()</code> method to handle sequential asynchronous tasks.</li>
        <pre>
myPromise
    .then(result => {
        console.log(result);
        return 'Next step';
    })
    .then(nextStep => console.log(nextStep))
    .catch(error => console.log(error));
        </pre>

        <li><strong>Promise.all:</strong> Use <code>Promise.all()</code> to handle multiple promises concurrently. It returns a single promise that resolves when all promises in the array have resolved.</li>
        <pre>
const promise1 = Promise.resolve('First');
const promise2 = Promise.resolve('Second');

Promise.all([promise1, promise2])
    .then(results => console.log(results)) // ['First', 'Second']
    .catch(error => console.log(error));
        </pre>
    </ul>
</div>

<!-- JavaScript Async/Await -->
<div class="section">
    <h2>146. JavaScript Async/Await</h2>
    <p>Async/await syntax is a way to write asynchronous code in a synchronous style, making it easier to read and maintain.</p>
    <ul>
        <li><strong>Using Async/Await:</strong> The <code>async</code> keyword is used to define an asynchronous function, and the <code>await</code> keyword pauses the execution of the async function until the promise is resolved.</li>
        <pre>
async function fetchData() {
    try {
        const response = await fetch('https://jsonplaceholder.typicode.com/posts');
        const data = await response.json();
        console.log(data);
    } catch (error) {
        console.log(error);
    }
}

fetchData();
        </pre>

        <li><strong>Handling Errors:</strong> Use <code>try...catch</code> blocks within async functions to handle errors in asynchronous code.</li>
    </ul>
</div>

<!-- JavaScript Modules -->
<div class="section">
    <h2>147. JavaScript Modules</h2>
    <p>JavaScript modules allow you to split your code into separate files and manage dependencies between them. Modules can export and import functions, objects, or values.</p>
    <ul>
        <li><strong>Exporting Modules:</strong> Use <code>export</code> to expose functions, objects, or values from a module.</li>
        <pre>
// utils.js
export function greet(name) {
    return `Hello, ${name}`;
}
        </pre>

        <li><strong>Importing Modules:</strong> Use <code>import</code> to include exported functionality from another module.</li>
        <pre>
// main.js
import { greet } from './utils.js';

console.log(greet('World')); // 'Hello, World'
        </pre>

        <li><strong>Default Exports:</strong> Use <code>export default</code> to export a single value or function from a module.</li>
        <pre>
// utils.js
export default function greet(name) {
    return `Hello, ${name}`;
}

// main.js
import greet from './utils.js';

console.log(greet('World')); // 'Hello, World'
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling -->
<div class="section">
    <h2>148. JavaScript Error Handling</h2>
    <p>JavaScript provides mechanisms for handling errors and exceptions to prevent crashes and provide a better user experience.</p>
    <ul>
        <li><strong>Try...Catch:</strong> Use <code>try...catch</code> to handle errors that occur during code execution.</li>
        <pre>
try {
    throw new Error('Something went wrong');
} catch (error) {
    console.log(error.message); // 'Something went wrong'
}
        </pre>

        <li><strong>Custom Errors:</strong> Create custom error types by extending the built-in <code>Error</code> class.</li>
        <pre>
class CustomError extends Error {
    constructor(message) {
        super(message);
        this.name = 'CustomError';
    }
}

throw new CustomError('This is a custom error');
        </pre>

        <li><strong>Handling Asynchronous Errors:</strong> Handle errors in asynchronous code using <code>.catch()</code> with promises or <code>try...catch</code> in async functions.</li>
    </ul>
</div>

<!-- JavaScript Debugging -->
<div class="section">
    <h2>149. JavaScript Debugging</h2>
    <p>Debugging is the process of identifying and fixing errors in your JavaScript code. Various tools and techniques can assist in this process.</p>
    <ul>
        <li><strong>Console.log:</strong> Use <code>console.log()</code> to output variable values and trace code execution.</li>
        <pre>
const value = 42;
console.log(value); // 42
        </pre>

        <li><strong>Breakpoints:</strong> Use breakpoints in browser developer tools to pause code execution and inspect variables.</li>
        <li><strong>Debugger Keyword:</strong> Insert the <code>debugger;</code> statement in your code to trigger a breakpoint.</li>
        <pre>
function calculate(a, b) {
    debugger; // Execution will pause here
    return a + b;
}
        </pre>
    </ul>
</div>

<!-- JavaScript Event Delegation -->
<div class="section">
    <h2>150. JavaScript Event Delegation</h2>
    <p>Event delegation is a technique of using a single event listener to manage events for multiple elements, often used with dynamically added elements.</p>
    <ul>
        <li><strong>Event Delegation Basics:</strong> Attach a single event listener to a parent element instead of multiple listeners to individual child elements.</li>
        <pre>
document.getElementById('parent').addEventListener('click', function(event) {
    if (event.target && event.target.matches('button.child')) {
        console.log('Child button clicked');
    }
});
        </pre>

        <li><strong>Benefits:</strong> Reduces memory usage and improves performance, especially when dealing with a large number of elements.</li>
    </ul>
</div>
<!-- JavaScript Event Loop -->
<div class="section">
    <h2>151. JavaScript Event Loop</h2>
    <p>The event loop is a fundamental part of JavaScript's concurrency model, allowing non-blocking execution of code. It handles asynchronous operations and ensures that the main thread remains responsive.</p>
    <ul>
        <li><strong>How the Event Loop Works:</strong> JavaScript executes code on the main thread, but it uses the event loop to manage asynchronous tasks like I/O operations, timers, and events. The event loop constantly checks the call stack and the task queue to execute pending callbacks.</li>
        <pre>
console.log('Start');

setTimeout(() => {
    console.log('Timeout');
}, 0);

console.log('End');
        </pre>

        <li><strong>Microtasks vs. Macrotasks:</strong> Microtasks (like promises) are processed before macrotasks (like `setTimeout`), allowing more immediate handling of asynchronous code.</li>
        <pre>
console.log('Start');

Promise.resolve().then(() => {
    console.log('Promise');
});

setTimeout(() => {
    console.log('Timeout');
}, 0);

console.log('End');
        </pre>
    </ul>
</div>

<!-- JavaScript Proxies -->
<div class="section">
    <h2>152. JavaScript Proxies</h2>
    <p>Proxies are a powerful feature in JavaScript that allows you to create an object that wraps another object and intercept operations performed on it, such as property access, assignment, and method calls.</p>
    <ul>
        <li><strong>Creating a Proxy:</strong> Use the <code>Proxy</code> constructor to create a proxy object, which takes a target object and a handler object that defines traps for operations.</li>
        <pre>
const target = {
    message: 'Hello'
};

const handler = {
    get: function(target, prop, receiver) {
        return prop in target ? target[prop] : 'Property does not exist';
    }
};

const proxy = new Proxy(target, handler);
console.log(proxy.message); // 'Hello'
console.log(proxy.nonExistent); // 'Property does not exist'
        </pre>

        <li><strong>Common Traps:</strong> Traps are methods that intercept operations. Common traps include <code>get</code>, <code>set</code>, <code>has</code>, and <code>deleteProperty</code>.</li>
    </ul>
</div>

<!-- JavaScript Generators -->
<div class="section">
    <h2>153. JavaScript Generators</h2>
    <p>Generators are functions that can be paused and resumed, allowing for more complex iteration and control flow patterns. They use the <code>function*</code> syntax and the <code>yield</code> keyword.</p>
    <ul>
        <li><strong>Creating Generators:</strong> Define a generator function using <code>function*</code>, and use <code>yield</code> to return values one at a time.</li>
        <pre>
function* generator() {
    yield 1;
    yield 2;
    yield 3;
}

const gen = generator();
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
console.log(gen.next().value); // 3
        </pre>

        <li><strong>Generator Iteration:</strong> Use the <code>next()</code> method to get the next value from the generator. Each call to <code>next()</code> resumes execution until the next <code>yield</code> or the end of the generator.</li>
    </ul>
</div>

<!-- JavaScript Map and Set -->
<div class="section">
    <h2>154. JavaScript Map and Set</h2>
    <p>Maps and Sets are built-in JavaScript objects for storing unique values and key-value pairs, respectively.</p>
    <ul>
        <li><strong>Map:</strong> A <code>Map</code> object holds key-value pairs where keys can be any data type. Maps maintain the insertion order of elements and provide methods for easy manipulation.</li>
        <pre>
const map = new Map();
map.set('name', 'Alice');
map.set('age', 25);

console.log(map.get('name')); // 'Alice'
console.log(map.has('age')); // true
console.log(map.size); // 2
        </pre>

        <li><strong>Set:</strong> A <code>Set</code> object lets you store unique values of any type. It automatically removes duplicate entries and maintains insertion order.</li>
        <pre>
const set = new Set();
set.add(1);
set.add(2);
set.add(2); // Duplicate value, will be ignored

console.log(set.has(1)); // true
console.log(set.size); // 2
        </pre>
    </ul>
</div>

<!-- JavaScript Symbols -->
<div class="section">
    <h2>155. JavaScript Symbols</h2>
    <p>Symbols are a new primitive type introduced in ECMAScript 6 that can be used as unique object property keys. They are immutable and can be used to create private properties.</p>
    <ul>
        <li><strong>Creating Symbols:</strong> Use the <code>Symbol()</code> function to create a new unique symbol. Each call to <code>Symbol()</code> returns a unique symbol value.</li>
        <pre>
const symbol1 = Symbol('description');
const symbol2 = Symbol('description');

console.log(symbol1 === symbol2); // false
        </pre>

        <li><strong>Using Symbols as Object Keys:</strong> Symbols can be used as property keys to create properties that are not enumerable in for...in loops or Object.keys().</li>
        <pre>
const mySymbol = Symbol('key');
const obj = {
    [mySymbol]: 'value'
};

console.log(obj[mySymbol]); // 'value'
        </pre>
    </ul>
</div>

<!-- JavaScript Regular Expressions -->
<div class="section">
    <h2>156. JavaScript Regular Expressions</h2>
    <p>Regular expressions are patterns used to match character combinations in strings. JavaScript supports regular expressions through the RegExp object.</p>
    <ul>
        <li><strong>Creating Regular Expressions:</strong> Use either a regular expression literal or the <code>RegExp</code> constructor to create a regular expression.</li>
        <pre>
const regexLiteral = /abc/;
const regexConstructor = new RegExp('abc');

console.log(regexLiteral.test('abcdef')); // true
console.log(regexConstructor.test('abcdef')); // true
        </pre>

        <li><strong>Common Methods:</strong> Regular expressions have methods like <code>test()</code>, <code>exec()</code>, and <code>replace()</code> for matching and manipulating strings.</li>
        <pre>
const pattern = /hello/i;
const str = 'Hello World';

console.log(pattern.test(str)); // true
console.log(str.replace(pattern, 'Hi')); // 'Hi World'
        </pre>
    </ul>
</div>

<!-- JavaScript Template Literals -->
<div class="section">
    <h2>157. JavaScript Template Literals</h2>
    <p>Template literals provide an easier way to create strings that can include expressions. They are defined using backticks (<code>`</code>) and support multi-line strings and embedded expressions.</p>
    <ul>
        <li><strong>Basic Usage:</strong> Use backticks to create template literals and include expressions using <code>${}</code>.</li>
        <pre>
const name = 'Alice';
const greeting = `Hello, ${name}!`;

console.log(greeting); // 'Hello, Alice!'
        </pre>

        <li><strong>Multi-line Strings:</strong> Template literals allow you to create multi-line strings without using escape characters.</li>
        <pre>
const multiLine = `This is a string
that spans multiple
lines.`;

console.log(multiLine);
        </pre>
    </ul>
</div>
<!-- JavaScript Destructuring -->
<div class="section">
    <h2>158. JavaScript Destructuring</h2>
    <p>Destructuring is a convenient way to extract multiple properties from arrays or objects and assign them to variables. It can be used for arrays, objects, and nested structures.</p>
    <ul>
        <li><strong>Array Destructuring:</strong> Extract values from arrays into variables using array destructuring syntax.</li>
        <pre>
const [first, second] = [1, 2];
console.log(first); // 1
console.log(second); // 2
        </pre>

        <li><strong>Object Destructuring:</strong> Extract properties from objects into variables using object destructuring syntax.</li>
        <pre>
const { name, age } = { name: 'Alice', age: 25 };
console.log(name); // 'Alice'
console.log(age); // 25
        </pre>

        <li><strong>Nested Destructuring:</strong> Extract values from nested arrays and objects using nested destructuring.</li>
        <pre>
const user = {
    name: 'Alice',
    address: { city: 'Wonderland', zip: '12345' }
};

const { name, address: { city } } = user;
console.log(name); // 'Alice'
console.log(city); // 'Wonderland'
        </pre>
    </ul>
</div>

<!-- JavaScript Async/Await -->
<div class="section">
    <h2>159. JavaScript Async/Await</h2>
    <p>Async/await is a syntax for working with asynchronous code that makes it look and behave more like synchronous code. It is built on top of Promises and simplifies error handling and chaining.</p>
    <ul>
        <li><strong>Using Async/Await:</strong> Define a function as <code>async</code> to use <code>await</code> inside it. Use <code>await</code> to pause execution until a promise is resolved or rejected.</li>
        <pre>
async function fetchData() {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    return data;
}

fetchData().then(data => console.log(data));
        </pre>

        <li><strong>Error Handling:</strong> Use <code>try/catch</code> blocks to handle errors in async functions.</li>
        <pre>
async function fetchData() {
    try {
        const response = await fetch('https://api.example.com/data');
        if (!response.ok) {
            throw new Error('Network response was not ok');
        }
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error:', error);
    }
}
        </pre>
    </ul>
</div>

<!-- JavaScript Classes -->
<div class="section">
    <h2>160. JavaScript Classes</h2>
    <p>Classes are a way to create objects with shared methods and properties. They provide a more structured way to handle object-oriented programming in JavaScript.</p>
    <ul>
        <li><strong>Creating a Class:</strong> Define a class using the <code>class</code> keyword, and use the <code>constructor</code> method to initialize properties.</li>
        <pre>
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        return `Hello, my name is ${this.name}.`;
    }
}

const alice = new Person('Alice', 25);
console.log(alice.greet()); // 'Hello, my name is Alice.'
        </pre>

        <li><strong>Inheritance:</strong> Use the <code>extends</code> keyword to create a subclass that inherits from a parent class.</li>
        <pre>
class Employee extends Person {
    constructor(name, age, jobTitle) {
        super(name, age);
        this.jobTitle = jobTitle;
    }

    introduce() {
        return `Hi, I'm ${this.name} and I work as a ${this.jobTitle}.`;
    }
}

const bob = new Employee('Bob', 30, 'Developer');
console.log(bob.introduce()); // 'Hi, I'm Bob and I work as a Developer.'
        </pre>
    </ul>
</div>

<!-- JavaScript Modules -->
<div class="section">
    <h2>161. JavaScript Modules</h2>
    <p>JavaScript modules allow you to split code into reusable pieces. Modules can export values and functions and import them into other modules.</p>
    <ul>
        <li><strong>Exporting:</strong> Use <code>export</code> to expose values or functions from a module.</li>
        <pre>
// module.js
export const name = 'Alice';
export function greet() {
    return 'Hello';
}
        </pre>

        <li><strong>Importing:</strong> Use <code>import</code> to bring in values or functions from other modules.</li>
        <pre>
// main.js
import { name, greet } from './module.js';

console.log(name); // 'Alice'
console.log(greet()); // 'Hello'
        </pre>

        <li><strong>Default Exports:</strong> Use <code>export default</code> to export a single value or function as the default export of a module.</li>
        <pre>
// module.js
export default function greet() {
    return 'Hello';
}

// main.js
import greet from './module.js';
console.log(greet()); // 'Hello'
        </pre>
    </ul>
</div>

<!-- JavaScript Closures -->
<div class="section">
    <h2>162. JavaScript Closures</h2>
    <p>A closure is a function that retains access to its lexical scope even when the function is executed outside that scope. Closures are useful for creating private variables and functions.</p>
    <ul>
        <li><strong>Creating Closures:</strong> Closures are created when a function is defined inside another function, allowing the inner function to access variables from the outer function.</li>
        <pre>
function createCounter() {
    let count = 0;

    return function() {
        count += 1;
        return count;
    };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
        </pre>

        <li><strong>Private Variables:</strong> Use closures to create private variables that are not accessible from outside the function.</li>
        <pre>
function makeSecret() {
    let secret = 'hidden';

    return {
        getSecret: function() {
            return secret;
        },
        setSecret: function(newSecret) {
            secret = newSecret;
        }
    };
}

const secretKeeper = makeSecret();
console.log(secretKeeper.getSecret()); // 'hidden'
secretKeeper.setSecret('revealed');
console.log(secretKeeper.getSecret()); // 'revealed'
        </pre>
    </ul>
</div>

<!-- JavaScript Event Delegation -->
<div class="section">
    <h2>163. JavaScript Event Delegation</h2>
    <p>Event delegation is a technique where you attach a single event listener to a parent element rather than to individual child elements. This approach can improve performance and simplify event handling.</p>
    <ul>
        <li><strong>Implementing Event Delegation:</strong> Attach an event listener to a parent element and use the event's <code>target</code> property to determine which child element triggered the event.</li>
        <pre>
document.getElementById('parent').addEventListener('click', function(event) {
    if (event.target && event.target.matches('button')) {
        console.log('Button clicked:', event.target.textContent);
    }
});
        </pre>

        <li><strong>Benefits:</strong> Event delegation reduces the number of event listeners attached to individual elements and handles events more efficiently by leveraging event bubbling.</li>
    </ul>
</div>
<!-- JavaScript Regular Expressions -->
<div class="section">
    <h2>164. JavaScript Regular Expressions</h2>
    <p>Regular expressions (regex) are patterns used to match character combinations in strings. They are powerful tools for string manipulation and validation.</p>
    <ul>
        <li><strong>Creating Regex:</strong> Use the <code>/pattern/flags</code> syntax or the <code>RegExp</code> constructor to create regular expressions.</li>
        <pre>
const regex1 = /abc/; // Pattern without flags
const regex2 = new RegExp('abc', 'i'); // Pattern with case-insensitive flag
        </pre>

        <li><strong>Using Regex Methods:</strong> Common methods include <code>test()</code>, <code>exec()</code>, <code>match()</code>, <code>replace()</code>, and <code>split()</code>.</li>
        <pre>
const str = 'Hello World';
const regex = /world/i;

console.log(regex.test(str)); // true
console.log(str.match(regex)); // ['World']
console.log(str.replace(regex, 'Universe')); // 'Hello Universe'
        </pre>

        <li><strong>Regex Patterns:</strong> Learn common patterns such as <code>\d</code> for digits, <code>\w</code> for word characters, <code>^</code> for the start of a string, and <code>$</code> for the end of a string.</li>
        <pre>
const phonePattern = /^\d{3}-\d{3}-\d{4}$/;
console.log(phonePattern.test('123-456-7890')); // true
        </pre>
    </ul>
</div>

<!-- JavaScript Closures and Private Methods -->
<div class="section">
    <h2>165. JavaScript Closures and Private Methods</h2>
    <p>Closures allow functions to access variables from their containing scopes, enabling private methods and properties that are not accessible from outside the function.</p>
    <ul>
        <li><strong>Private Methods:</strong> Define methods within a closure to encapsulate and protect data.</li>
        <pre>
function Counter() {
    let count = 0;

    this.increment = function() {
        count += 1;
        return count;
    };

    this.getCount = function() {
        return count;
    };
}

const counter = new Counter();
console.log(counter.increment()); // 1
console.log(counter.getCount()); // 1
        </pre>

        <li><strong>Module Pattern:</strong> Use closures to create modules with private and public parts.</li>
        <pre>
const module = (function() {
    let privateVar = 'I am private';

    return {
        publicVar: 'I am public',
        getPrivateVar: function() {
            return privateVar;
        }
    };
})();

console.log(module.publicVar); // 'I am public'
console.log(module.getPrivateVar()); // 'I am private'
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling -->
<div class="section">
    <h2>166. JavaScript Error Handling</h2>
    <p>JavaScript provides mechanisms to handle errors gracefully using <code>try</code>, <code>catch</code>, <code>finally</code>, and <code>throw</code>.</p>
    <ul>
        <li><strong>Using try/catch:</strong> Wrap code that might throw an error in a <code>try</code> block and handle exceptions in a <code>catch</code> block.</li>
        <pre>
try {
    throw new Error('Something went wrong');
} catch (error) {
    console.error(error.message); // 'Something went wrong'
}
        </pre>

        <li><strong>Using finally:</strong> Use <code>finally</code> to execute code regardless of whether an error was thrown or not.</li>
        <pre>
try {
    // Code that may throw an error
} catch (error) {
    // Handle the error
} finally {
    // Always executed
}
        </pre>

        <li><strong>Throwing Errors:</strong> Use <code>throw</code> to manually create and throw errors.</li>
        <pre>
function validateAge(age) {
    if (age < 0) {
        throw new Error('Age cannot be negative');
    }
    return age;
}

try {
    validateAge(-5);
} catch (error) {
    console.error(error.message); // 'Age cannot be negative'
}
        </pre>
    </ul>
</div>

<!-- JavaScript Event Loop -->
<div class="section">
    <h2>167. JavaScript Event Loop</h2>
    <p>The event loop is a core concept in JavaScript that handles asynchronous operations and manages the execution of code in a non-blocking manner.</p>
    <ul>
        <li><strong>Understanding the Event Loop:</strong> The event loop continuously checks the call stack and the message queue, executing tasks from the queue when the stack is empty.</li>
        <pre>
console.log('Start');

setTimeout(() => {
    console.log('Timeout');
}, 0);

console.log('End');

// Output:
// Start
// End
// Timeout
        </pre>

        <li><strong>Microtasks and Macrotasks:</strong> Microtasks (like promises) are executed before macrotasks (like setTimeout) in the event loop.</li>
        <pre>
console.log('Start');

Promise.resolve().then(() => console.log('Microtask'));

setTimeout(() => {
    console.log('Macrotask');
}, 0);

console.log('End');

// Output:
// Start
// End
// Microtask
// Macrotask
        </pre>

        <li><strong>Event Loop Phases:</strong> The event loop has different phases, including timers, I/O callbacks, idle, prepare, poll, check, and close callbacks.</li>
    </ul>
</div>

<!-- JavaScript Prototypes and Inheritance -->
<div class="section">
    <h2>168. JavaScript Prototypes and Inheritance</h2>
    <p>JavaScript uses prototypes to enable inheritance and reuse properties and methods between objects.</p>
    <ul>
        <li><strong>Prototypes:</strong> Each JavaScript object has a prototype property that points to another object, allowing inheritance of properties and methods.</li>
        <pre>
function Person(name) {
    this.name = name;
}

Person.prototype.greet = function() {
    return `Hello, my name is ${this.name}.`;
};

const alice = new Person('Alice');
console.log(alice.greet()); // 'Hello, my name is Alice.'
        </pre>

        <li><strong>Inheritance:</strong> Use prototypes to create subclasses and inherit properties and methods from parent objects.</li>
        <pre>
function Employee(name, jobTitle) {
    Person.call(this, name);
    this.jobTitle = jobTitle;
}

Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;

Employee.prototype.introduce = function() {
    return `Hi, I'm ${this.name} and I work as a ${this.jobTitle}.`;
};

const bob = new Employee('Bob', 'Developer');
console.log(bob.introduce()); // 'Hi, I'm Bob and I work as a Developer.'
        </pre>
    </ul>
</div>

<!-- JavaScript Set and Map -->
<div class="section">
    <h2>169. JavaScript Set and Map</h2>
    <p>Sets and Maps are new collection types introduced in ES6 that allow you to store unique values and key-value pairs, respectively.</p>
    <ul>
        <li><strong>Set:</strong> A Set is a collection of unique values. It can be used to store any type of values and automatically removes duplicates.</li>
        <pre>
const mySet = new Set([1, 2, 3, 4, 4]);
console.log(mySet); // Set { 1, 2, 3, 4 }
console.log(mySet.has(3)); // true
mySet.add(5);
mySet.delete(2);
console.log(mySet.size); // 4
        </pre>

        <li><strong>Map:</strong> A Map is a collection of key-value pairs where keys can be any data type and values are associated with unique keys.</li>
        <pre>
const myMap = new Map();
myMap.set('name', 'Alice');
myMap.set('age', 25);
console.log(myMap.get('name')); // 'Alice'
console.log(myMap.has('age')); // true
myMap.delete('age');
console.log(myMap.size); // 1
        </pre>

        <li><strong>Iterating Sets and Maps:</strong> Use the <code>forEach</code> method or iterators to loop through values in Sets and key-value pairs in Maps.</li>
        <pre>
mySet.forEach(value => console.log(value));
myMap.forEach((value, key) => console.log(`${key}: ${value}`));
        </pre>
    </ul>
</div>

<!-- JavaScript Symbol -->
<div class="section">
    <h2>170. JavaScript Symbol</h2>
    <p>Symbols are a new primitive type introduced in ES6 that can be used as unique property keys, avoiding name clashes.</p>
    <ul>
        <li><strong>Creating Symbols:</strong> Use the <code>Symbol</code> function to create unique symbols.</li>
        <pre>
const sym1 = Symbol('description');
const sym2 = Symbol('description');
console.log(sym1 === sym2); // false
        </pre>

        <li><strong>Using Symbols as Object Keys:</strong> Symbols can be used as keys for object properties, ensuring uniqueness.</li>
        <pre>
const mySymbol = Symbol('mySymbol');
const obj = {
    [mySymbol]: 'value'
};
console.log(obj[mySymbol]); // 'value'
        </pre>

        <li><strong>Well-Known Symbols:</strong> JavaScript defines several built-in symbols, such as <code>Symbol.iterator</code> and <code>Symbol.toStringTag</code>, for various purposes.</li>
        <pre>
const iterable = {
    [Symbol.iterator]: function*() {
        yield 1;
        yield 2;
        yield 3;
    }
};

for (const value of iterable) {
    console.log(value); // 1, 2, 3
}
        </pre>
    </ul>
</div>
<!-- JavaScript Async/Await -->
<div class="section">
    <h2>171. JavaScript Async/Await</h2>
    <p>Async/await is a syntax introduced in ES8 (ES2017) that makes working with asynchronous code easier by allowing you to write asynchronous code in a synchronous style.</p>
    <ul>
        <li><strong>Async Functions:</strong> Declare functions as <code>async</code> to enable the use of <code>await</code> within them.</li>
        <pre>
async function fetchData() {
    return 'Data fetched';
}

fetchData().then(data => console.log(data)); // 'Data fetched'
        </pre>

        <li><strong>Await Expressions:</strong> Use <code>await</code> to pause the execution of an async function until a promise is resolved or rejected.</li>
        <pre>
async function getData() {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    return data;
}

getData().then(data => console.log(data));
        </pre>

        <li><strong>Error Handling with Async/Await:</strong> Use <code>try/catch</code> blocks to handle errors in async functions.</li>
        <pre>
async function getData() {
    try {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        return data;
    } catch (error) {
        console.error('Error fetching data:', error);
    }
}

getData();
        </pre>
    </ul>
</div>

<!-- JavaScript Generators -->
<div class="section">
    <h2>172. JavaScript Generators</h2>
    <p>Generators are functions that can be paused and resumed, allowing you to define an iterative algorithm by using the <code>function*</code> syntax and the <code>yield</code> keyword.</p>
    <ul>
        <li><strong>Creating Generators:</strong> Define a generator function using <code>function*</code> and use <code>yield</code> to produce values.</li>
        <pre>
function* numberGenerator() {
    yield 1;
    yield 2;
    yield 3;
}

const generator = numberGenerator();
console.log(generator.next().value); // 1
console.log(generator.next().value); // 2
console.log(generator.next().value); // 3
        </pre>

        <li><strong>Using Generators:</strong> Use <code>next()</code> to get the next value and <code>done</code> to check if the generator is finished.</li>
        <pre>
function* counter() {
    let count = 0;
    while (true) {
        yield count++;
    }
}

const gen = counter();
console.log(gen.next().value); // 0
console.log(gen.next().value); // 1
console.log(gen.next().value); // 2
        </pre>

        <li><strong>Generator Methods:</strong> Generators can also be used with <code>return</code> and <code>throw</code> for more advanced control over iteration.</li>
        <pre>
function* generatorWithReturn() {
    yield 'start';
    yield 'middle';
    return 'end';
}

const gen = generatorWithReturn();
console.log(gen.next()); // { value: 'start', done: false }
console.log(gen.next()); // { value: 'middle', done: false }
console.log(gen.next()); // { value: 'end', done: true }
        </pre>
    </ul>
</div>

<!-- JavaScript WeakMap and WeakSet -->
<div class="section">
    <h2>173. JavaScript WeakMap and WeakSet</h2>
    <p>WeakMap and WeakSet are specialized collections that allow for garbage collection of objects when there are no other references to them.</p>
    <ul>
        <li><strong>WeakMap:</strong> A WeakMap is a collection of key-value pairs where the keys must be objects and values can be any data type. The keys are held weakly, meaning they can be garbage collected if there are no other references to them.</li>
        <pre>
const weakMap = new WeakMap();
const obj = {};

weakMap.set(obj, 'value');
console.log(weakMap.get(obj)); // 'value'

obj = null; // obj can be garbage collected
        </pre>

        <li><strong>WeakSet:</strong> A WeakSet is a collection of objects where the objects are held weakly. Like WeakMap, objects in a WeakSet can be garbage collected if there are no other references to them.</li>
        <pre>
const weakSet = new WeakSet();
const obj = {};

weakSet.add(obj);
console.log(weakSet.has(obj)); // true

obj = null; // obj can be garbage collected
        </pre>
    </ul>
</div>

<!-- JavaScript Proxy -->
<div class="section">
    <h2>174. JavaScript Proxy</h2>
    <p>The Proxy object enables you to create a handler for an object that can intercept and redefine fundamental operations (e.g., property lookup, assignment).</p>
    <ul>
        <li><strong>Creating a Proxy:</strong> Define a Proxy by passing an object to be proxied and a handler object that contains traps for different operations.</li>
        <pre>
const handler = {
    get(target, prop) {
        return prop in target ? target[prop] : 'Property does not exist';
    }
};

const target = { name: 'John' };
const proxy = new Proxy(target, handler);

console.log(proxy.name); // 'John'
console.log(proxy.age); // 'Property does not exist'
        </pre>

        <li><strong>Common Traps:</strong> Common traps include <code>get</code>, <code>set</code>, <code>has</code>, <code>deleteProperty</code>, and more.</li>
        <pre>
const handler = {
    set(target, prop, value) {
        if (typeof value === 'number') {
            target[prop] = value;
            return true;
        } else {
            throw new TypeError('Value must be a number');
        }
    }
};

const target = {};
const proxy = new Proxy(target, handler);

proxy.age = 25; // Success
console.log(proxy.age); // 25
proxy.age = 'string'; // Throws TypeError
        </pre>
    </ul>
</div>

<!-- JavaScript Reflection -->
<div class="section">
    <h2>175. JavaScript Reflection</h2>
    <p>Reflection in JavaScript involves using the <code>Reflect</code> API to intercept and interact with the object operations.</p>
    <ul>
        <li><strong>Using Reflect:</strong> The <code>Reflect</code> API provides methods for performing operations on objects, such as getting and setting properties, calling functions, and more.</li>
        <pre>
const obj = { name: 'Alice' };
console.log(Reflect.get(obj, 'name')); // 'Alice'

Reflect.set(obj, 'name', 'Bob');
console.log(obj.name); // 'Bob'
        </pre>

        <li><strong>Reflect vs Proxy:</strong> While <code>Proxy</code> allows for customizing object behavior, <code>Reflect</code> provides methods to perform default operations on objects and can be used within Proxy handlers.</li>
        <pre>
const handler = {
    get(target, prop) {
        return Reflect.get(target, prop);
    }
};

const target = { name: 'Alice' };
const proxy = new Proxy(target, handler);

console.log(proxy.name); // 'Alice'
        </pre>
    </ul>
</div>

<!-- JavaScript Modules -->
<div class="section">
    <h2>176. JavaScript Modules</h2>
    <p>JavaScript modules allow you to split code into separate files and control the visibility of variables and functions. Modules can be imported and exported using the <code>import</code> and <code>export</code> keywords.</p>
    <ul>
        <li><strong>Exporting:</strong> Use <code>export</code> to make functions, objects, or variables available for use in other modules.</li>
        <pre>
export function add(x, y) {
    return x + y;
}

export const pi = 3.14;
        </pre>

        <li><strong>Importing:</strong> Use <code>import</code> to bring in functions, objects, or variables from other modules.</li>
        <pre>
import { add, pi } from './math.js';

console.log(add(2, 3)); // 5
console.log(pi); // 3.14
        </pre>

        <li><strong>Default Exports:</strong> Use <code>export default</code> for a single value or object to be exported from a module.</li>
        <pre>
export default function multiply(x, y) {
    return x * y;
}
        </pre>
    </ul>
</div>

<!-- JavaScript Web APIs -->
<div class="section">
    <h2>177. JavaScript Web APIs</h2>
    <p>Web APIs provide JavaScript access to browser and server functionalities. These APIs enable interaction with the web page, perform network requests, handle user input, and more.</p>
    <ul>
        <li><strong>DOM API:</strong> The Document Object Model (DOM) API allows you to interact with and manipulate HTML and XML documents.</li>
        <pre>
const header = document.querySelector('h1');
header.textContent = 'New Header Text';
        </pre>

        <li><strong>Fetch API:</strong> The Fetch API provides a modern way to make network requests and handle responses.</li>
        <pre>
fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data));
        </pre>

        <li><strong>LocalStorage and SessionStorage:</strong> These storage mechanisms allow you to store data in the browser for persistence.</li>
        <pre>
localStorage.setItem('key', 'value');
console.log(localStorage.getItem('key')); // 'value'

sessionStorage.setItem('sessionKey', 'sessionValue');
console.log(sessionStorage.getItem('sessionKey')); // 'sessionValue'
        </pre>
    </ul>
</div>
<!-- JavaScript Asynchronous Iteration -->
<div class="section">
    <h2>178. JavaScript Asynchronous Iteration</h2>
    <p>Asynchronous iteration allows you to loop through asynchronous data sources, such as streams or data fetched from a network, using the <code>for-await-of</code> loop.</p>
    <ul>
        <li><strong>Async Iterators:</strong> Objects that implement the <code>Symbol.asyncIterator</code> method are called async iterators and can be used with <code>for-await-of</code> loops.</li>
        <pre>
async function* asyncGenerator() {
    yield 'First';
    yield 'Second';
    yield 'Third';
}

for await (const value of asyncGenerator()) {
    console.log(value); // 'First', 'Second', 'Third'
}
        </pre>

        <li><strong>Using Async Iterators with Streams:</strong> Streams are a common use case for async iteration, allowing you to process data chunks as they become available.</li>
        <pre>
async function readStream(stream) {
    const reader = stream.getReader();
    while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        console.log(value);
    }
}

const stream = new ReadableStream({
    start(controller) {
        controller.enqueue('Hello');
        controller.enqueue('World');
        controller.close();
    }
});

readStream(stream);
        </pre>
    </ul>
</div>

<!-- JavaScript WeakRef -->
<div class="section">
    <h2>179. JavaScript WeakRef</h2>
    <p>The <code>WeakRef</code> object allows you to create a weak reference to an object, which does not prevent the object from being garbage collected.</p>
    <ul>
        <li><strong>Creating Weak References:</strong> Use the <code>WeakRef</code> constructor to create a weak reference to an object.</li>
        <pre>
let obj = { name: 'Alice' };
const weakRef = new WeakRef(obj);

console.log(weakRef.deref()); // { name: 'Alice' }

obj = null; // The object can be garbage collected
console.log(weakRef.deref()); // null (if garbage collected)
        </pre>

        <li><strong>Use Cases:</strong> Weak references are useful for caching and implementing certain kinds of data structures that should not prevent garbage collection.</li>
    </ul>
</div>

<!-- JavaScript BigInt -->
<div class="section">
    <h2>180. JavaScript BigInt</h2>
    <p>BigInt is a built-in object that provides a way to represent and operate on integers that are larger than 2<sup>53</sup> - 1, which is the limit of the standard Number type.</p>
    <ul>
        <li><strong>Creating BigInt Values:</strong> BigInt values are created using the <code>BigInt</code> constructor or by appending <code>n</code> to integer literals.</li>
        <pre>
const bigInt1 = BigInt(123456789012345678901234567890);
const bigInt2 = 123456789012345678901234567890n;

console.log(bigInt1 === bigInt2); // true
        </pre>

        <li><strong>Operations with BigInt:</strong> BigInt supports basic arithmetic operations, but mixing BigInt with Number requires explicit conversion.</li>
        <pre>
const bigInt1 = 1000000000000000000000000000n;
const bigInt2 = 2000000000000000000000000000n;

console.log(bigInt1 + bigInt2); // 3000000000000000000000000000n
console.log(bigInt1 * bigInt2); // 2000000000000000000000000000000000000000000000000000n

// Mixing BigInt and Number requires conversion
const num = 10;
console.log(bigInt1 + BigInt(num)); // 1000000000000000000000000010n
        </pre>
    </ul>
</div>

<!-- JavaScript Intl API -->
<div class="section">
    <h2>181. JavaScript Intl API</h2>
    <p>The Internationalization API (<code>Intl</code>) provides functionality for language-sensitive operations, such as number formatting, date and time formatting, and more.</p>
    <ul>
        <li><strong>Number Formatting:</strong> Use <code>Intl.NumberFormat</code> to format numbers according to locale-specific conventions.</li>
        <pre>
const number = 123456.789;

const formatterUS = new Intl.NumberFormat('en-US');
console.log(formatterUS.format(number)); // 123,456.789

const formatterDE = new Intl.NumberFormat('de-DE');
console.log(formatterDE.format(number)); // 123.456,789
        </pre>

        <li><strong>Date and Time Formatting:</strong> Use <code>Intl.DateTimeFormat</code> to format dates and times according to locale-specific conventions.</li>
        <pre>
const date = new Date();

const formatterUS = new Intl.DateTimeFormat('en-US', { dateStyle: 'full', timeStyle: 'long' });
console.log(formatterUS.format(date)); // Sunday, September 19, 2024 at 9:30:00 PM Eastern Daylight Time

const formatterJP = new Intl.DateTimeFormat('ja-JP', { dateStyle: 'full' });
console.log(formatterJP.format(date)); // 2024919
        </pre>

        <li><strong>Collation:</strong> Use <code>Intl.Collator</code> for locale-sensitive string comparison and sorting.</li>
        <pre>
const collatorUS = new Intl.Collator('en-US');
const collatorFR = new Intl.Collator('fr-FR');

console.log(collatorUS.compare('apple', 'banana')); // -1
console.log(collatorFR.compare('apple', 'banana')); // -1
        </pre>
    </ul>
</div>
<!-- JavaScript Modules -->
<div class="section">
    <h2>182. JavaScript Modules</h2>
    <p>JavaScript modules allow you to break up your code into reusable pieces and manage dependencies between them. Modules help in organizing code and maintaining encapsulation.</p>
    <ul>
        <li><strong>Exporting Modules:</strong> Use the <code>export</code> keyword to make functions, objects, or values available outside the module.</li>
        <pre>
// file: math.js
export const PI = 3.14159;

export function add(a, b) {
    return a + b;
}
        </pre>

        <li><strong>Importing Modules:</strong> Use the <code>import</code> keyword to include exported functions, objects, or values from another module.</li>
        <pre>
// file: main.js
import { PI, add } from './math.js';

console.log(PI); // 3.14159
console.log(add(2, 3)); // 5
        </pre>

        <li><strong>Default Exports:</strong> A module can export a single value or function as the default export using the <code>export default</code> keyword.</li>
        <pre>
// file: greet.js
export default function greet(name) {
    console.log(`Hello, ${name}`);
}
        </pre>

        <li><strong>Importing Default Exports:</strong> Import the default export without using curly braces.</li>
        <pre>
// file: app.js
import greet from './greet.js';

greet('Alice'); // Hello, Alice
        </pre>

        <li><strong>Dynamic Imports:</strong> Use <code>import()</code> function to load modules dynamically. This allows code splitting and lazy loading.</li>
        <pre>
// file: dynamic.js
async function loadModule() {
    const module = await import('./math.js');
    console.log(module.PI); // 3.14159
}

loadModule();
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling -->
<div class="section">
    <h2>183. JavaScript Error Handling</h2>
    <p>Handling errors effectively in JavaScript helps in maintaining robust and user-friendly applications. JavaScript provides mechanisms for handling errors using <code>try...catch</code>, <code>throw</code>, and <code>finally</code>.</p>
    <ul>
        <li><strong>Try-Catch Statement:</strong> Use <code>try...catch</code> to handle exceptions and prevent application crashes.</li>
        <pre>
try {
    // Code that may throw an error
    let result = riskyFunction();
} catch (error) {
    // Handle the error
    console.error('An error occurred:', error);
}
        </pre>

        <li><strong>Throwing Errors:</strong> Use the <code>throw</code> statement to create custom error messages and throw exceptions.</li>
        <pre>
function divide(a, b) {
    if (b === 0) {
        throw new Error('Division by zero is not allowed');
    }
    return a / b;
}

try {
    console.log(divide(10, 0));
} catch (error) {
    console.error(error.message); // 'Division by zero is not allowed'
}
        </pre>

        <li><strong>Finally Block:</strong> The <code>finally</code> block, if present, will always execute regardless of whether an error was thrown or not.</li>
        <pre>
try {
    // Code that may throw an error
    let result = riskyFunction();
} catch (error) {
    // Handle the error
    console.error('An error occurred:', error);
} finally {
    // Code to execute regardless of error
    console.log('Execution completed');
}
        </pre>

        <li><strong>Custom Error Classes:</strong> Create custom error classes to represent specific types of errors in your application.</li>
        <pre>
class ValidationError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ValidationError';
    }
}

function validateUser(user) {
    if (!user.email) {
        throw new ValidationError('Email is required');
    }
}

try {
    validateUser({});
} catch (error) {
    if (error instanceof ValidationError) {
        console.error('Validation Error:', error.message);
    } else {
        console.error('General Error:', error.message);
    }
}
        </pre>
    </ul>
</div>

<!-- JavaScript Advanced Array Methods -->
<div class="section">
    <h2>184. JavaScript Advanced Array Methods</h2>
    <p>Advanced array methods in JavaScript provide powerful ways to manipulate and transform arrays. These methods include <code>map</code>, <code>filter</code>, <code>reduce</code>, and more.</p>
    <ul>
        <li><strong>Map Method:</strong> Use <code>map()</code> to create a new array with the results of applying a function to every element of the original array.</li>
        <pre>
const numbers = [1, 2, 3, 4];
const squares = numbers.map(x => x * x);

console.log(squares); // [1, 4, 9, 16]
        </pre>

        <li><strong>Filter Method:</strong> Use <code>filter()</code> to create a new array with elements that pass a test implemented by a provided function.</li>
        <pre>
const numbers = [1, 2, 3, 4];
const evens = numbers.filter(x => x % 2 === 0);

console.log(evens); // [2, 4]
        </pre>

        <li><strong>Reduce Method:</strong> Use <code>reduce()</code> to execute a reducer function on each element of the array, resulting in a single output value.</li>
        <pre>
const numbers = [1, 2, 3, 4];
const sum = numbers.reduce((acc, current) => acc + current, 0);

console.log(sum); // 10
        </pre>

        <li><strong>Some and Every Methods:</strong> Use <code>some()</code> to test if at least one element in the array passes the test and <code>every()</code> to test if all elements pass the test.</li>
        <pre>
const numbers = [1, 2, 3, 4];

const hasEven = numbers.some(x => x % 2 === 0);
console.log(hasEven); // true

const allEven = numbers.every(x => x % 2 === 0);
console.log(allEven); // false
        </pre>
    </ul>
</div>
</body>
</html>