<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JsNotes</title>
    <link rel="stylesheet" href="./cm.css">
</head>
<body>
    <!-- JavaScript Basics -->
<div class="section">
    <h2>1. JavaScript Basics</h2>
    <p>JavaScript is a versatile scripting language used to create interactive and dynamic web pages.</p>
    <ul>
        <li><strong>Variables:</strong> Used to store data values. Declared using <code>var</code>, <code>let</code>, or <code>const</code>.</li>
        <pre>
let name = "John";  // Using let
const age = 30;     // Using const
        </pre>

        <li><strong>Data Types:</strong> JavaScript supports various data types including <code>string</code>, <code>number</code>, <code>boolean</code>, <code>object</code>, and <code>array</code>.</li>
        <pre>
let str = "Hello, world!";  // String
let num = 100;              // Number
let isTrue = true;          // Boolean
        </pre>

        <li><strong>Operators:</strong> JavaScript provides operators for arithmetic, comparison, and logical operations.</li>
        <pre>
let sum = 10 + 5;           // Arithmetic
let isEqual = (5 == 5);    // Comparison
let andResult = (true && false); // Logical
        </pre>
    </ul>
</div>

<!-- Functions -->
<div class="section">
    <h2>2. Functions</h2>
    <p>Functions are reusable blocks of code that perform a specific task.</p>
    <ul>
        <li><strong>Function Declaration:</strong> Defines a function using the <code>function</code> keyword.</li>
        <pre>
function greet(name) {
  return "Hello, " + name;
}
        </pre>

        <li><strong>Function Expression:</strong> Defines a function as part of an expression.</li>
        <pre>
const add = function(a, b) {
  return a + b;
};
        </pre>

        <li><strong>Arrow Functions:</strong> A shorter syntax for function expressions.</li>
        <pre>
const multiply = (a, b) => a * b;
        </pre>
    </ul>
</div>

<!-- Objects -->
<div class="section">
    <h2>3. Objects</h2>
    <p>Objects are collections of key-value pairs.</p>
    <ul>
        <li><strong>Creating Objects:</strong> Objects can be created using object literals or constructors.</li>
        <pre>
let person = {
  name: "Alice",
  age: 25,
  greet: function() {
    return "Hello, " + this.name;
  }
};
        </pre>

        <li><strong>Accessing Object Properties:</strong> Properties can be accessed using dot notation or bracket notation.</li>
        <pre>
console.log(person.name);  // Dot notation
console.log(person["age"]); // Bracket notation
        </pre>

        <li><strong>Object Methods:</strong> Functions that are properties of objects.</li>
        <pre>
person.greet();  // Calls the greet method
        </pre>
    </ul>
</div>

<!-- Arrays -->
<div class="section">
    <h2>4. Arrays</h2>
    <p>Arrays are ordered collections of values.</p>
    <ul>
        <li><strong>Creating Arrays:</strong> Arrays can be created using array literals or the <code>Array</code> constructor.</li>
        <pre>
let numbers = [1, 2, 3, 4, 5];
let fruits = new Array("apple", "banana", "cherry");
        </pre>

        <li><strong>Accessing Array Elements:</strong> Elements can be accessed using their index.</li>
        <pre>
console.log(numbers[0]);  // 1
console.log(fruits[2]);   // cherry
        </pre>

        <li><strong>Array Methods:</strong> Arrays come with various methods such as <code>push()</code>, <code>pop()</code>, <code>shift()</code>, <code>unshift()</code>, <code>map()</code>, and <code>filter()</code>.</li>
        <pre>
numbers.push(6);  // Adds 6 to the end of the array
fruits.map(fruit => fruit.toUpperCase()); // Converts all fruits to uppercase
        </pre>
    </ul>
</div>

<!-- DOM Manipulation -->
<div class="section">
    <h2>5. DOM Manipulation</h2>
    <p>JavaScript can be used to interact with and manipulate the DOM (Document Object Model).</p>
    <ul>
        <li><strong>Selecting Elements:</strong> Use methods like <code>getElementById()</code>, <code>querySelector()</code>, and <code>getElementsByClassName()</code>.</li>
        <pre>
let element = document.getElementById("myElement");
let items = document.querySelectorAll(".item");
        </pre>

        <li><strong>Modifying Elements:</strong> Change content, attributes, and styles of elements.</li>
        <pre>
element.textContent = "New Content";
element.style.color = "blue";
        </pre>

        <li><strong>Event Handling:</strong> Attach event listeners to elements to handle user interactions.</li>
        <pre>
element.addEventListener("click", function() {
  alert("Element clicked!");
});
        </pre>
    </ul>
</div>

<!-- Asynchronous JavaScript -->
<div class="section">
    <h2>6. Asynchronous JavaScript</h2>
    <p>Asynchronous JavaScript allows you to execute code without blocking the main thread.</p>
    <ul>
        <li><strong>Callbacks:</strong> Functions passed as arguments to other functions that are executed after a task is completed.</li>
        <pre>
function fetchData(callback) {
  setTimeout(() => {
    callback("Data fetched");
  }, 1000);
}
fetchData(function(data) {
  console.log(data);
});
        </pre>

        <li><strong>Promises:</strong> Represent a value that may be available now or in the future. Methods include <code>then()</code>, <code>catch()</code>, and <code>finally()</code>.</li>
        <pre>
let promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve("Data fetched"), 1000);
});
promise.then(data => console.log(data));
        </pre>

        <li><strong>Async/Await:</strong> Simplifies working with promises by using <code>async</code> and <code>await</code> keywords.</li>
        <pre>
async function fetchData() {
  let response = await fetch("https://api.example.com/data");
  let data = await response.json();
  console.log(data);
}
fetchData();
        </pre>
    </ul>
</div>

<!-- Error Handling -->
<div class="section">
    <h2>7. Error Handling</h2>
    <p>JavaScript provides mechanisms to handle errors gracefully.</p>
    <ul>
        <li><strong>Try/Catch:</strong> A block used to handle exceptions.</li>
        <pre>
try {
  throw new Error("Something went wrong");
} catch (error) {
  console.log(error.message);
} finally {
  console.log("Cleanup code");
}
        </pre>

        <li><strong>Throwing Errors:</strong> Use the <code>throw</code> statement to create custom errors.</li>
        <pre>
function validateAge(age) {
  if (age < 18) throw new Error("Age must be 18 or older");
}
        </pre>
    </ul>
</div>

<!-- ES6 Features -->
<div class="section">
    <h2>8. ES6 Features</h2>
    <p>ES6 (ECMAScript 2015) introduced several new features to JavaScript.</p>
    <ul>
        <li><strong>Template Literals:</strong> Allows embedded expressions and multi-line strings.</li>
        <pre>
let name = "John";
let greeting = `Hello, ${name}`;
        </pre>

        <li><strong>Destructuring:</strong> Extracts values from arrays or properties from objects into variables.</li>
        <pre>
let [x, y] = [1, 2];
let {a, b} = {a: 1, b: 2};
        </pre>

        <li><strong>Default Parameters:</strong> Assign default values to function parameters.</li>
        <pre>
function greet(name = "Guest") {
  return "Hello, " + name;
}
        </pre>

        <li><strong>Spread Operator:</strong> Expands an array into individual elements or combines objects.</li>
        <pre>
let arr = [1, 2, 3];
let newArr = [...arr, 4, 5];
let obj1 = {a: 1};
let obj2 = {b: 2};
let merged = {...obj1, ...obj2};
        </pre>
    </ul>
</div>
<!-- JavaScript Classes -->
<div class="section">
    <h2>9. JavaScript Classes</h2>
    <p>Classes in JavaScript provide a way to create objects and handle inheritance.</p>
    <ul>
        <li><strong>Creating Classes:</strong> Use the <code>class</code> keyword to define a class.</li>
        <pre>
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
  
  greet() {
    return `Hello, my name is ${this.name}`;
  }
}
        </pre>

        <li><strong>Inheritance:</strong> Extend a class using the <code>extends</code> keyword.</li>
        <pre>
class Employee extends Person {
  constructor(name, age, position) {
    super(name, age);
    this.position = position;
  }
  
  describe() {
    return `${this.name} is a ${this.position}`;
  }
}
        </pre>
    </ul>
</div>

<!-- Modules -->
<div class="section">
    <h2>10. Modules</h2>
    <p>Modules in JavaScript allow you to split your code into separate files.</p>
    <ul>
        <li><strong>Exporting Modules:</strong> Use the <code>export</code> keyword to export functions, objects, or variables from a module.</li>
        <pre>
export function add(a, b) {
  return a + b;
}
        </pre>

        <li><strong>Importing Modules:</strong> Use the <code>import</code> keyword to import functionalities from a module.</li>
        <pre>
import { add } from './math.js';
console.log(add(2, 3)); // 5
        </pre>

        <li><strong>Default Exports:</strong> Export a single default value from a module.</li>
        <pre>
export default function subtract(a, b) {
  return a - b;
}
        </pre>
    </ul>
</div>

<!-- Event Delegation -->
<div class="section">
    <h2>11. Event Delegation</h2>
    <p>Event delegation allows you to manage events for dynamically created elements.</p>
    <ul>
        <li><strong>Concept:</strong> Attach a single event listener to a parent element to manage events for its child elements.</li>
        <pre>
document.getElementById('parent').addEventListener('click', function(event) {
  if (event.target && event.target.matches('button.child')) {
    alert('Button clicked!');
  }
});
        </pre>

        <li><strong>Benefits:</strong> Reduces the number of event listeners and handles dynamic content.</li>
    </ul>
</div>

<!-- Error Handling with Promises -->
<div class="section">
    <h2>12. Error Handling with Promises</h2>
    <p>Handling errors in promises ensures your code can gracefully handle failures.</p>
    <ul>
        <li><strong>Using <code>catch()</code>:</strong> Attach a <code>catch()</code> method to handle rejected promises.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Using <code>finally()</code>:</strong> Perform cleanup actions regardless of promise outcome.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error))
  .finally(() => console.log('Fetch attempt finished.'));
        </pre>
    </ul>
</div>

<!-- Fetch API -->
<div class="section">
    <h2>13. Fetch API</h2>
    <p>The Fetch API provides a modern way to make HTTP requests.</p>
    <ul>
        <li><strong>Making Requests:</strong> Use the <code>fetch()</code> function to make requests to servers.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data));
        </pre>

        <li><strong>Handling Responses:</strong> Check the response status and handle data accordingly.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) throw new Error('Network response was not ok');
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error('Fetch error:', error));
        </pre>

        <li><strong>Sending Data:</strong> Use options to send data with requests.</li>
        <pre>
fetch('https://api.example.com/data', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  body: JSON.stringify({ key: 'value' })
})
  .then(response => response.json())
  .then(data => console.log(data));
        </pre>
    </ul>
</div>

<!-- Local Storage -->
<div class="section">
    <h2>14. Local Storage</h2>
    <p>Local Storage provides a way to store data in the browser.</p>
    <ul>
        <li><strong>Storing Data:</strong> Use <code>localStorage.setItem()</code> to store data.</li>
        <pre>
localStorage.setItem('name', 'John Doe');
        </pre>

        <li><strong>Retrieving Data:</strong> Use <code>localStorage.getItem()</code> to retrieve stored data.</li>
        <pre>
let name = localStorage.getItem('name');
console.log(name); // John Doe
        </pre>

        <li><strong>Removing Data:</strong> Use <code>localStorage.removeItem()</code> to remove specific items.</li>
        <pre>
localStorage.removeItem('name');
        </pre>

        <li><strong>Clearing All Data:</strong> Use <code>localStorage.clear()</code> to clear all data.</li>
        <pre>
localStorage.clear();
        </pre>
    </ul>
</div>

<!-- Session Storage -->
<div class="section">
    <h2>15. Session Storage</h2>
    <p>Session Storage provides a way to store data for the duration of the page session.</p>
    <ul>
        <li><strong>Storing Data:</strong> Use <code>sessionStorage.setItem()</code> to store data for the session.</li>
        <pre>
sessionStorage.setItem('sessionName', 'Jane Doe');
        </pre>

        <li><strong>Retrieving Data:</strong> Use <code>sessionStorage.getItem()</code> to retrieve session data.</li>
        <pre>
let sessionName = sessionStorage.getItem('sessionName');
console.log(sessionName); // Jane Doe
        </pre>

        <li><strong>Removing Data:</strong> Use <code>sessionStorage.removeItem()</code> to remove specific session items.</li>
        <pre>
sessionStorage.removeItem('sessionName');
        </pre>

        <li><strong>Clearing All Data:</strong> Use <code>sessionStorage.clear()</code> to clear all session data.</li>
        <pre>
sessionStorage.clear();
        </pre>
    </ul>
</div>

<!-- JavaScript Debugging -->
<div class="section">
    <h2>16. JavaScript Debugging</h2>
    <p>Debugging JavaScript helps you identify and fix issues in your code.</p>
    <ul>
        <li><strong>Using <code>console.log()</code>:</strong> Print messages to the console for debugging purposes.</li>
        <pre>
console.log('Debug message');
        </pre>

        <li><strong>Using Breakpoints:</strong> Set breakpoints in your browser's developer tools to pause execution and inspect variables.</li>

        <li><strong>Using <code>debugger</code> Statement:</strong> Add the <code>debugger</code> statement in your code to trigger a breakpoint.</li>
        <pre>
function test() {
  debugger;
  console.log('Code execution paused');
}
test();
        </pre>
    </ul>
</div>
<!-- Asynchronous JavaScript -->
<div class="section">
    <h2>17. Asynchronous JavaScript</h2>
    <p>Asynchronous JavaScript allows you to perform operations without blocking the main thread.</p>
    <ul>
        <li><strong>Callbacks:</strong> Functions passed as arguments to other functions, executed after a task is complete.</li>
        <pre>
function fetchData(callback) {
  setTimeout(() => {
    callback('Data fetched');
  }, 1000);
}

fetchData(data => console.log(data));
        </pre>

        <li><strong>Promises:</strong> Represent the result of an asynchronous operation. Can be in one of three states: pending, fulfilled, or rejected.</li>
        <pre>
const promise = new Promise((resolve, reject) => {
  setTimeout(() => resolve('Promise resolved'), 1000);
});

promise.then(result => console.log(result)).catch(error => console.error(error));
        </pre>

        <li><strong>Async/Await:</strong> Syntax for handling promises in a more synchronous fashion.</li>
        <pre>
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}

fetchData();
        </pre>
    </ul>
</div>

<!-- Error Handling -->
<div class="section">
    <h2>18. Error Handling</h2>
    <p>Handle errors to ensure your code can recover gracefully from unexpected situations.</p>
    <ul>
        <li><strong>Try/Catch:</strong> Use <code>try</code> and <code>catch</code> blocks to handle exceptions.</li>
        <pre>
try {
  throw new Error('An error occurred');
} catch (error) {
  console.error(error.message);
}
        </pre>

        <li><strong>Throwing Errors:</strong> Use the <code>throw</code> statement to create custom errors.</li>
        <pre>
function checkAge(age) {
  if (age < 18) {
    throw new Error('Age must be 18 or older');
  }
}

try {
  checkAge(15);
} catch (error) {
  console.error(error.message);
}
        </pre>
    </ul>
</div>

<!-- JavaScript Closures -->
<div class="section">
    <h2>19. JavaScript Closures</h2>
    <p>Closures allow a function to access variables from an outer scope even after the outer function has finished executing.</p>
    <ul>
        <li><strong>Concept:</strong> Functions that "remember" the environment in which they were created.</li>
        <pre>
function outerFunction() {
  let outerVar = 'I am from outer scope';
  return function innerFunction() {
    console.log(outerVar);
  };
}

const closure = outerFunction();
closure(); // I am from outer scope
        </pre>

        <li><strong>Practical Use:</strong> Closures can be used to create private variables or functions.</li>
        <pre>
function createCounter() {
  let count = 0;
  return function() {
    count += 1;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
        </pre>
    </ul>
</div>

<!-- JavaScript Prototypes -->
<div class="section">
    <h2>20. JavaScript Prototypes</h2>
    <p>Prototypes enable inheritance and sharing properties between objects.</p>
    <ul>
        <li><strong>Prototype Chain:</strong> Objects inherit properties from their prototype.</li>
        <pre>
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  return `Hello, my name is ${this.name}`;
};

const person = new Person('Alice');
console.log(person.greet()); // Hello, my name is Alice
        </pre>

        <li><strong>Inheritance with Prototypes:</strong> Create a prototype-based inheritance hierarchy.</li>
        <pre>
function Employee(name, position) {
  Person.call(this, name);
  this.position = position;
}

Employee.prototype = Object.create(Person.prototype);
Employee.prototype.constructor = Employee;

Employee.prototype.describe = function() {
  return `${this.name} is a ${this.position}`;
};

const employee = new Employee('Bob', 'Developer');
console.log(employee.describe()); // Bob is a Developer
        </pre>
    </ul>
</div>

<!-- JavaScript Regular Expressions -->
<div class="section">
    <h2>21. JavaScript Regular Expressions</h2>
    <p>Regular expressions (regex) are patterns used to match character combinations in strings.</p>
    <ul>
        <li><strong>Creating Regular Expressions:</strong> Use the <code>/pattern/</code> syntax or the <code>RegExp</code> constructor.</li>
        <pre>
const regex = /hello/;
const regex2 = new RegExp('hello');

console.log(regex.test('hello world')); // true
console.log(regex2.test('world hello')); // true
        </pre>

        <li><strong>Common Methods:</strong> <code>test()</code> to check if a pattern matches, <code>exec()</code> to retrieve matches.</li>
        <pre>
const str = 'The quick brown fox';
const match = /quick/.exec(str);
console.log(match[0]); // quick
        </pre>

        <li><strong>Modifiers:</strong> Add flags to regular expressions, such as <code>g</code> (global), <code>i</code> (case-insensitive).</li>
        <pre>
const regex = /hello/i;
console.log(regex.test('Hello World')); // true
        </pre>
    </ul>
</div>

<!-- JavaScript Iterators -->
<div class="section">
    <h2>22. JavaScript Iterators</h2>
    <p>Iterators provide a way to access elements of a collection one at a time.</p>
    <ul>
        <li><strong>Creating Iterators:</strong> Use the <code>Symbol.iterator</code> method to create an iterator for an object.</li>
        <pre>
const iterable = {
  items: ['apple', 'banana', 'cherry'],
  [Symbol.iterator]() {
    let index = 0;
    const items = this.items;
    return {
      next() {
        if (index < items.length) {
          return { value: items[index++], done: false };
        }
        return { done: true };
      }
    };
  }
};

for (const item of iterable) {
  console.log(item);
}
        </pre>

        <li><strong>Custom Iterators:</strong> Define custom behavior for iteration by implementing the iterator protocol.</li>
    </ul>
</div>

<!-- JavaScript Generators -->
<div class="section">
    <h2>23. JavaScript Generators</h2>
    <p>Generators are functions that can be paused and resumed, providing a powerful way to handle iteration.</p>
    <ul>
        <li><strong>Creating Generators:</strong> Use the <code>function* </code> syntax to define a generator function.</li>
        <pre>
function* generatorFunction() {
  yield 'first';
  yield 'second';
  yield 'third';
}

const generator = generatorFunction();
console.log(generator.next().value); // first
console.log(generator.next().value); // second
console.log(generator.next().value); // third
        </pre>

        <li><strong>Yielding Values:</strong> Use <code>yield</code> to pause execution and return values.</li>

        <li><strong>Generator Iteration:</strong> Use the <code>for...of</code> loop to iterate over generator values.</li>
        <pre>
for (const value of generatorFunction()) {
  console.log(value);
}
        </pre>
    </ul>
</div>

<!-- JavaScript Closures -->
<div class="section">
    <h2>24. JavaScript Closures</h2>
    <p>Closures allow functions to access variables from their outer scope even after the outer function has executed.</p>
    <ul>
        <li><strong>Concept:</strong> Functions that maintain access to variables from their outer scope.</li>
        <pre>
function makeCounter() {
  let count = 0;
  return function() {
    count += 1;
    return count;
  };
}

const counter = makeCounter();
console.log(counter()); // 1
console.log(counter()); // 2
        </pre>

        <li><strong>Use Cases:</strong> Useful for creating private variables and function factories.</li>
    </ul>
</div>

<!-- JavaScript Event Loop -->
<div class="section">
    <h2>25. JavaScript Event Loop</h2>
    <p>The event loop handles asynchronous operations and manages the execution of code.</p>
    <ul>
        <li><strong>Concept:</strong> The event loop allows JavaScript to perform non-blocking operations by putting tasks on a queue.</li>
        <pre>
console.log('Start');

setTimeout(() => {
  console.log('Timeout');
}, 0);

console.log('End');
        </pre>

        <li><strong>Microtasks vs. Macrotasks:</strong> Microtasks (e.g., promises) are executed before macrotasks (e.g., setTimeout).</li>
    </ul>
</div>
<!-- JavaScript Modules -->
<div class="section">
    <h2>26. JavaScript Modules</h2>
    <p>Modules help in organizing and encapsulating code, allowing you to export and import functionalities between files.</p>
    <ul>
        <li><strong>Exporting:</strong> Use <code>export</code> to make functions, objects, or variables available outside the module.</li>
        <pre>
// math.js
export function add(a, b) {
  return a + b;
}

export const pi = 3.14;
        </pre>

        <li><strong>Importing:</strong> Use <code>import</code> to bring in functionalities from other modules.</li>
        <pre>
// main.js
import { add, pi } from './math.js';

console.log(add(2, 3)); // 5
console.log(pi); // 3.14
        </pre>

        <li><strong>Default Exports:</strong> Use <code>export default</code> for exporting a single value or function.</li>
        <pre>
// utils.js
export default function greet(name) {
  return `Hello, ${name}`;
}

// main.js
import greet from './utils.js';

console.log(greet('Alice')); // Hello, Alice
        </pre>
    </ul>
</div>

<!-- JavaScript Async Iteration -->
<div class="section">
    <h2>27. JavaScript Async Iteration</h2>
    <p>Async iteration allows you to work with asynchronous data sources in a synchronous manner.</p>
    <ul>
        <li><strong>Async Iterators:</strong> Implement <code>Symbol.asyncIterator</code> to create asynchronous iterators.</li>
        <pre>
const asyncIterable = {
  async *[Symbol.asyncIterator]() {
    yield 'first';
    yield 'second';
    yield 'third';
  }
};

(async () => {
  for await (const value of asyncIterable) {
    console.log(value);
  }
})();
        </pre>

        <li><strong>For Await Of:</strong> Use <code>for await...of</code> to iterate over async iterables.</li>
    </ul>
</div>

<!-- JavaScript Proxies -->
<div class="section">
    <h2>28. JavaScript Proxies</h2>
    <p>Proxies enable you to define custom behavior for fundamental operations (e.g., property lookup, assignment).</p>
    <ul>
        <li><strong>Creating Proxies:</strong> Use the <code>Proxy</code> constructor to define traps for operations on objects.</li>
        <pre>
const target = {};
const handler = {
  get(target, property) {
    return property in target ? target[property] : 'Default value';
  }
};

const proxy = new Proxy(target, handler);
console.log(proxy.someProperty); // Default value
        </pre>

        <li><strong>Common Traps:</strong> Common traps include <code>get</code>, <code>set</code>, <code>has</code>, and <code>deleteProperty</code>.</li>
    </ul>
</div>

<!-- JavaScript Reflect -->
<div class="section">
    <h2>29. JavaScript Reflect</h2>
    <p>The <code>Reflect</code> API provides methods to interact with objects and perform operations in a more predictable manner.</p>
    <ul>
        <li><strong>Reflect Methods:</strong> Methods include <code>Reflect.get()</code>, <code>Reflect.set()</code>, <code>Reflect.has()</code>, etc.</li>
        <pre>
const obj = { name: 'Alice' };

console.log(Reflect.get(obj, 'name')); // Alice
Reflect.set(obj, 'name', 'Bob');
console.log(obj.name); // Bob
        </pre>

        <li><strong>Using Reflect with Proxies:</strong> Use <code>Reflect</code> methods inside proxy handlers for default behavior.</li>
        <pre>
const handler = {
  get(target, property) {
    return Reflect.get(target, property);
  }
};

const proxy = new Proxy(obj, handler);
console.log(proxy.name); // Bob
        </pre>
    </ul>
</div>

<!-- JavaScript Event Delegation -->
<div class="section">
    <h2>30. JavaScript Event Delegation</h2>
    <p>Event delegation involves attaching a single event listener to a parent element to manage events for its children.</p>
    <ul>
        <li><strong>Concept:</strong> Utilize event bubbling to handle events at a higher level.</li>
        <pre>
document.getElementById('parent').addEventListener('click', function(event) {
  if (event.target.matches('.child')) {
    console.log('Child element clicked');
  }
});
        </pre>

        <li><strong>Advantages:</strong> Reduces the number of event listeners, improves performance, and handles dynamically added elements.</li>
    </ul>
</div>

<!-- JavaScript Memory Management -->
<div class="section">
    <h2>31. JavaScript Memory Management</h2>
    <p>JavaScript manages memory automatically but understanding memory management helps avoid leaks and optimize performance.</p>
    <ul>
        <li><strong>Garbage Collection:</strong> JavaScript uses garbage collection to free memory used by objects that are no longer reachable.</li>
        <pre>
let obj = { name: 'Alice' };
obj = null; // The object is eligible for garbage collection
        </pre>

        <li><strong>Memory Leaks:</strong> Common causes include global variables, closures, and forgotten timers.</li>
        <pre>
function createLeak() {
  const largeArray = new Array(1000000).fill('memory leak');
  return function() {
    console.log(largeArray[0]);
  };
}

const leak = createLeak();
        </pre>
    </ul>
</div>

<!-- JavaScript Design Patterns -->
<div class="section">
    <h2>32. JavaScript Design Patterns</h2>
    <p>Design patterns are reusable solutions to common problems in software design.</p>
    <ul>
        <li><strong>Singleton Pattern:</strong> Ensures a class has only one instance and provides a global point of access.</li>
        <pre>
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this;
    }
    return Singleton.instance;
  }
}

const instance1 = new Singleton();
const instance2 = new Singleton();
console.log(instance1 === instance2); // true
        </pre>

        <li><strong>Module Pattern:</strong> Encapsulates private data and methods within an IIFE.</li>
        <pre>
const Module = (function() {
  let privateVar = 'I am private';

  return {
    getPrivateVar() {
      return privateVar;
    }
  };
})();

console.log(Module.getPrivateVar()); // I am private
        </pre>
    </ul>
</div>
<!-- JavaScript Closures -->
<div class="section">
    <h2>33. JavaScript Closures</h2>
    <p>A closure is a function that retains access to its lexical scope, even when the function is executed outside that scope.</p>
    <ul>
        <li><strong>Creating Closures:</strong> A closure is created when a function is defined inside another function and retains access to its outer function's variables.</li>
        <pre>
function outer() {
  let outerVar = 'I am outer';
  
  function inner() {
    console.log(outerVar); // Accesses outerVar
  }
  
  return inner;
}

const closureFunction = outer();
closureFunction(); // I am outer
        </pre>

        <li><strong>Use Cases:</strong> Closures are useful for data encapsulation, creating private variables, and function factories.</li>
    </ul>
</div>

<!-- JavaScript Event Loop -->
<div class="section">
    <h2>34. JavaScript Event Loop</h2>
    <p>The event loop allows JavaScript to execute code, handle events, and perform non-blocking operations while maintaining a single-threaded execution.</p>
    <ul>
        <li><strong>Call Stack:</strong> Keeps track of function calls. JavaScript executes functions in a Last In, First Out (LIFO) order.</li>
        <pre>
function sayHello() {
  console.log('Hello');
}

sayHello();
        </pre>

        <li><strong>Callback Queue:</strong> Holds functions that are waiting to be executed after the current script completes.</li>
        <pre>
setTimeout(() => {
  console.log('Executed after 1 second');
}, 1000);
        </pre>

        <li><strong>Microtask Queue:</strong> Holds promises and other microtasks that should be executed after the current task but before rendering.</li>
        <pre>
Promise.resolve().then(() => {
  console.log('Microtask executed');
});
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling -->
<div class="section">
    <h2>35. JavaScript Error Handling</h2>
    <p>Error handling is crucial for debugging and ensuring smooth user experiences in your applications.</p>
    <ul>
        <li><strong>Try-Catch:</strong> Use <code>try...catch</code> to handle exceptions and manage errors gracefully.</li>
        <pre>
try {
  throw new Error('Something went wrong');
} catch (error) {
  console.log(error.message); // Something went wrong
}
        </pre>

        <li><strong>Finally Block:</strong> The <code>finally</code> block executes after <code>try</code> and <code>catch</code>, regardless of the outcome.</li>
        <pre>
try {
  // Code that may throw an error
} catch (error) {
  // Handle error
} finally {
  // Cleanup code
}
        </pre>

        <li><strong>Custom Errors:</strong> Create custom error classes to handle specific types of errors.</li>
        <pre>
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = 'CustomError';
  }
}

throw new CustomError('Custom error message');
        </pre>
    </ul>
</div>

<!-- JavaScript Regular Expressions -->
<div class="section">
    <h2>36. JavaScript Regular Expressions</h2>
    <p>Regular expressions (regex) are patterns used to match character combinations in strings.</p>
    <ul>
        <li><strong>Creating Regex:</strong> Use <code>/pattern/</code> or <code>new RegExp('pattern')</code> to create regex objects.</li>
        <pre>
const regex = /hello/i; // Case-insensitive match for 'hello'
        </pre>

        <li><strong>Regex Methods:</strong> Common methods include <code>test()</code> to check for matches, <code>exec()</code> to extract matches, and <code>match()</code> to retrieve matches from a string.</li>
        <pre>
const str = 'Hello World';
console.log(regex.test(str)); // true
console.log(str.match(regex)); // ['Hello']
        </pre>

        <li><strong>Regex Flags:</strong> Flags modify the behavior of regex patterns. Common flags include <code>g</code> (global), <code>i</code> (case-insensitive), and <code>m</code> (multiline).</li>
    </ul>
</div>

<!-- JavaScript JSON -->
<div class="section">
    <h2>37. JavaScript JSON</h2>
    <p>JSON (JavaScript Object Notation) is a lightweight format for storing and exchanging data.</p>
    <ul>
        <li><strong>Parsing JSON:</strong> Use <code>JSON.parse()</code> to convert a JSON string into a JavaScript object.</li>
        <pre>
const jsonString = '{"name": "Alice", "age": 25}';
const obj = JSON.parse(jsonString);
console.log(obj.name); // Alice
        </pre>

        <li><strong>Stringifying JSON:</strong> Use <code>JSON.stringify()</code> to convert a JavaScript object into a JSON string.</li>
        <pre>
const obj = { name: 'Alice', age: 25 };
const jsonString = JSON.stringify(obj);
console.log(jsonString); // {"name":"Alice","age":25}
        </pre>

        <li><strong>JSON vs. JavaScript Objects:</strong> JSON is a text format for data interchange, while JavaScript objects are in-memory data structures.</li>
    </ul>
</div>

<!-- JavaScript Date and Time -->
<div class="section">
    <h2>38. JavaScript Date and Time</h2>
    <p>JavaScript provides the <code>Date</code> object to work with dates and times.</p>
    <ul>
        <li><strong>Creating Date Objects:</strong> Use the <code>Date</code> constructor to create date objects.</li>
        <pre>
const now = new Date();
console.log(now); // Current date and time
        </pre>

        <li><strong>Date Methods:</strong> Common methods include <code>getFullYear()</code>, <code>getMonth()</code>, and <code>getDate()</code> for retrieving parts of the date.</li>
        <pre>
const date = new Date();
console.log(date.getFullYear()); // 2024
console.log(date.getMonth()); // 8 (September, 0-indexed)
console.log(date.getDate()); // 19
        </pre>

        <li><strong>Formatting Dates:</strong> Use libraries like <code>date-fns</code> or <code>moment.js</code> for advanced date formatting and manipulation.</li>
    </ul>
</div>

<!-- JavaScript Fetch API -->
<div class="section">
    <h2>39. JavaScript Fetch API</h2>
    <p>The Fetch API provides a modern way to make HTTP requests to servers and handle responses.</p>
    <ul>
        <li><strong>Making Requests:</strong> Use the <code>fetch()</code> function to make network requests and handle responses.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Handling Responses:</strong> Use methods like <code>response.json()</code>, <code>response.text()</code>, and <code>response.blob()</code> to process different types of responses.</li>
    </ul>
</div>

<!-- JavaScript Web Storage -->
<div class="section">
    <h2>40. JavaScript Web Storage</h2>
    <p>Web Storage provides ways to store data on the client side with <code>localStorage</code> and <code>sessionStorage</code>.</p>
    <ul>
        <li><strong>Local Storage:</strong> Stores data with no expiration time. Use <code>localStorage</code> to save data that persists across sessions.</li>
        <pre>
localStorage.setItem('key', 'value');
console.log(localStorage.getItem('key')); // value
        </pre>

        <li><strong>Session Storage:</strong> Stores data for the duration of the page session. Use <code>sessionStorage</code> for data that is only needed during the current session.</li>
        <pre>
sessionStorage.setItem('key', 'value');
console.log(sessionStorage.getItem('key')); // value
        </pre>

        <li><strong>Removing Data:</strong> Use <code>removeItem()</code> to delete specific items and <code>clear()</code> to remove all items.</li>
    </ul>
</div>
<!-- JavaScript Promises -->
<div class="section">
    <h2>41. JavaScript Promises</h2>
    <p>Promises are objects that represent the eventual completion (or failure) of an asynchronous operation and its resulting value.</p>
    <ul>
        <li><strong>Creating Promises:</strong> Use the <code>Promise</code> constructor to create a new promise and specify the <code>resolve</code> and <code>reject</code> functions.</li>
        <pre>
const myPromise = new Promise((resolve, reject) => {
  // Simulate an asynchronous operation
  setTimeout(() => {
    resolve('Success!');
  }, 1000);
});

myPromise.then(result => console.log(result)); // Success!
        </pre>

        <li><strong>Chaining Promises:</strong> Use <code>.then()</code> to chain multiple operations and <code>.catch()</code> to handle errors.</li>
        <pre>
myPromise
  .then(result => {
    console.log(result); // Success!
    return 'Next step';
  })
  .then(nextResult => console.log(nextResult)) // Next step
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Promise.all:</strong> Use <code>Promise.all()</code> to run multiple promises in parallel and wait for all of them to complete.</li>
        <pre>
Promise.all([
  Promise.resolve('First'),
  Promise.resolve('Second')
]).then(results => console.log(results)); // ['First', 'Second']
        </pre>
    </ul>
</div>

<!-- JavaScript Async/Await -->
<div class="section">
    <h2>42. JavaScript Async/Await</h2>
    <p>Async/await syntax simplifies working with promises by allowing you to write asynchronous code in a synchronous style.</p>
    <ul>
        <li><strong>Async Functions:</strong> Use the <code>async</code> keyword before a function to make it return a promise.</li>
        <pre>
async function fetchData() {
  return 'Data fetched';
}

fetchData().then(data => console.log(data)); // Data fetched
        </pre>

        <li><strong>Await Keyword:</strong> Use <code>await</code> inside an <code>async</code> function to wait for a promise to resolve.</li>
        <pre>
async function getData() {
  const data = await myPromise;
  console.log(data); // Success!
}

getData();
        </pre>

        <li><strong>Handling Errors:</strong> Use <code>try...catch</code> within an async function to handle errors.</li>
        <pre>
async function getData() {
  try {
    const data = await myPromise;
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}

getData();
        </pre>
    </ul>
</div>

<!-- JavaScript Modules -->
<div class="section">
    <h2>43. JavaScript Modules</h2>
    <p>Modules allow you to split your code into separate files, making it easier to manage and maintain.</p>
    <ul>
        <li><strong>Exporting Modules:</strong> Use <code>export</code> to make variables, functions, or classes available in other files.</li>
        <pre>
export const greeting = 'Hello';

export function greet(name) {
  return `${greeting}, ${name}!`;
}
        </pre>

        <li><strong>Importing Modules:</strong> Use <code>import</code> to bring in exported members from other modules.</li>
        <pre>
import { greeting, greet } from './myModule.js';

console.log(greeting); // Hello
console.log(greet('Alice')); // Hello, Alice!
        </pre>

        <li><strong>Default Exports:</strong> Use <code>export default</code> to export a single value or function as the default export of a module.</li>
        <pre>
export default function greet(name) {
  return `Hello, ${name}!`;
}
        </pre>

        <li><strong>Dynamic Imports:</strong> Use <code>import()</code> to load modules dynamically.</li>
        <pre>
import('./myModule.js')
  .then(module => {
    console.log(module.greet('Alice'));
  });
        </pre>
    </ul>
</div>

<!-- JavaScript DOM Manipulation -->
<div class="section">
    <h2>44. JavaScript DOM Manipulation</h2>
    <p>DOM manipulation involves using JavaScript to interact with and modify the structure and content of HTML documents.</p>
    <ul>
        <li><strong>Selecting Elements:</strong> Use methods like <code>document.querySelector()</code> and <code>document.getElementById()</code> to select elements.</li>
        <pre>
const element = document.querySelector('.myClass');
console.log(element); // Logs the first element with class 'myClass'
        </pre>

        <li><strong>Modifying Elements:</strong> Change element content and attributes using properties like <code>innerText</code>, <code>innerHTML</code>, and <code>setAttribute()</code>.</li>
        <pre>
const element = document.querySelector('#myElement');
element.innerText = 'New content';
element.setAttribute('data-info', 'some data');
        </pre>

        <li><strong>Creating Elements:</strong> Use <code>document.createElement()</code> to create new elements and <code>appendChild()</code> to add them to the DOM.</li>
        <pre>
const newElement = document.createElement('div');
newElement.innerText = 'I am a new element';
document.body.appendChild(newElement);
        </pre>

        <li><strong>Event Handling:</strong> Add event listeners using <code>addEventListener()</code> to respond to user actions.</li>
        <pre>
const button = document.querySelector('button');
button.addEventListener('click', () => {
  alert('Button clicked!');
});
        </pre>
    </ul>
</div>

<!-- JavaScript Local Storage -->
<div class="section">
    <h2>45. JavaScript Local Storage</h2>
    <p>Local Storage allows you to store data in the browser with no expiration time, meaning data persists across sessions.</p>
    <ul>
        <li><strong>Setting Items:</strong> Use <code>localStorage.setItem()</code> to store data as key-value pairs.</li>
        <pre>
localStorage.setItem('username', 'Alice');
        </pre>

        <li><strong>Getting Items:</strong> Use <code>localStorage.getItem()</code> to retrieve stored data.</li>
        <pre>
const username = localStorage.getItem('username');
console.log(username); // Alice
        </pre>

        <li><strong>Removing Items:</strong> Use <code>localStorage.removeItem()</code> to delete a specific item and <code>localStorage.clear()</code> to remove all items.</li>
        <pre>
localStorage.removeItem('username');
        </pre>
    </ul>
</div>

<!-- JavaScript Session Storage -->
<div class="section">
    <h2>46. JavaScript Session Storage</h2>
    <p>Session Storage is similar to Local Storage but only persists for the duration of the page session.</p>
    <ul>
        <li><strong>Setting Items:</strong> Use <code>sessionStorage.setItem()</code> to store data for the current session.</li>
        <pre>
sessionStorage.setItem('sessionData', 'Session data');
        </pre>

        <li><strong>Getting Items:</strong> Use <code>sessionStorage.getItem()</code> to retrieve session data.</li>
        <pre>
const sessionData = sessionStorage.getItem('sessionData');
console.log(sessionData); // Session data
        </pre>

        <li><strong>Removing Items:</strong> Use <code>sessionStorage.removeItem()</code> to delete a specific item and <code>sessionStorage.clear()</code> to remove all session data.</li>
        <pre>
sessionStorage.removeItem('sessionData');
        </pre>
    </ul>
</div>
<!-- JavaScript Closures -->
<div class="section">
    <h2>47. JavaScript Closures</h2>
    <p>A closure is a function that retains access to its lexical scope even when the function is executed outside that scope.</p>
    <ul>
        <li><strong>Understanding Closures:</strong> Closures allow a function to access variables from an outer function even after the outer function has finished executing.</li>
        <pre>
function outerFunction() {
  let outerVariable = 'I am outside!';
  
  function innerFunction() {
    console.log(outerVariable);
  }
  
  return innerFunction;
}

const myClosure = outerFunction();
myClosure(); // I am outside!
        </pre>

        <li><strong>Use Cases:</strong> Closures are often used for data encapsulation and creating private variables.</li>
        <pre>
function createCounter() {
  let count = 0;
  
  return function() {
    count += 1;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
        </pre>
    </ul>
</div>

<!-- JavaScript Event Delegation -->
<div class="section">
    <h2>48. JavaScript Event Delegation</h2>
    <p>Event delegation is a technique where a single event handler is added to a parent element to manage events for multiple child elements.</p>
    <ul>
        <li><strong>Why Use Event Delegation?</strong> It helps in managing events efficiently when dealing with dynamically added elements or many child elements.</li>
        <pre>
document.querySelector('#parent').addEventListener('click', (event) => {
  if (event.target.matches('.child')) {
    console.log('Child element clicked');
  }
});
        </pre>

        <li><strong>Example:</strong> Adding a click event to dynamically added child elements.</li>
        <pre>
const parent = document.querySelector('#parent');

parent.addEventListener('click', (event) => {
  if (event.target.classList.contains('child')) {
    alert('Child clicked!');
  }
});

// Dynamically add a child element
const newChild = document.createElement('div');
newChild.classList.add('child');
newChild.textContent = 'Click me!';
parent.appendChild(newChild);
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling -->
<div class="section">
    <h2>49. JavaScript Error Handling</h2>
    <p>Error handling is crucial for managing exceptions and preventing crashes in your JavaScript code.</p>
    <ul>
        <li><strong>Try...Catch:</strong> Use <code>try...catch</code> to catch and handle errors.</li>
        <pre>
try {
  // Code that may throw an error
  let result = riskyOperation();
} catch (error) {
  console.error('An error occurred:', error);
}
        </pre>

        <li><strong>Throwing Errors:</strong> Use <code>throw</code> to manually create and throw an error.</li>
        <pre>
function checkNumber(num) {
  if (num <= 0) {
    throw new Error('Number must be positive');
  }
  return num;
}

try {
  console.log(checkNumber(-1));
} catch (error) {
  console.error(error.message); // Number must be positive
}
        </pre>

        <li><strong>Custom Errors:</strong> Create custom error types by extending the built-in <code>Error</code> class.</li>
        <pre>
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = 'CustomError';
  }
}

throw new CustomError('This is a custom error');
        </pre>
    </ul>
</div>

<!-- JavaScript Regular Expressions -->
<div class="section">
    <h2>50. JavaScript Regular Expressions</h2>
    <p>Regular expressions (regex) are patterns used to match character combinations in strings.</p>
    <ul>
        <li><strong>Creating Regex:</strong> Use the <code>RegExp</code> constructor or regex literals.</li>
        <pre>
const regex = /abc/;
const regexConstructor = new RegExp('abc');
        </pre>

        <li><strong>Testing Strings:</strong> Use <code>test()</code> to check if a string matches the regex pattern.</li>
        <pre>
const pattern = /hello/;
console.log(pattern.test('hello world')); // true
        </pre>

        <li><strong>Matching Strings:</strong> Use <code>match()</code> to find matches of the pattern in a string.</li>
        <pre>
const text = 'The quick brown fox jumps over the lazy dog';
const matches = text.match(/o./g);
console.log(matches); // ['ow', 'ox', 'og']
        </pre>

        <li><strong>Replacing Text:</strong> Use <code>replace()</code> to replace text based on the regex pattern.</li>
        <pre>
const newText = text.replace(/o./g, 'XX');
console.log(newText); // The quick brXXwn fXX jumps Xver the lazy dXg
        </pre>
    </ul>
</div>

<!-- JavaScript Date and Time -->
<div class="section">
    <h2>51. JavaScript Date and Time</h2>
    <p>The <code>Date</code> object is used to work with dates and times in JavaScript.</p>
    <ul>
        <li><strong>Creating Date Objects:</strong> Use the <code>Date</code> constructor to create date objects.</li>
        <pre>
const now = new Date();
const specificDate = new Date('2024-01-01');
        </pre>

        <li><strong>Getting Date and Time:</strong> Use methods like <code>getDate()</code>, <code>getMonth()</code>, and <code>getFullYear()</code> to retrieve specific components of the date.</li>
        <pre>
const today = new Date();
console.log(today.getDate()); // Day of the month
console.log(today.getMonth()); // Month (0-11)
console.log(today.getFullYear()); // Year
        </pre>

        <li><strong>Formatting Dates:</strong> Use methods or libraries like <code>toLocaleDateString()</code> for formatting dates.</li>
        <pre>
const date = new Date();
console.log(date.toLocaleDateString()); // Format depends on locale
        </pre>

        <li><strong>Date Arithmetic:</strong> Perform operations like adding days or calculating differences between dates.</li>
        <pre>
const futureDate = new Date();
futureDate.setDate(futureDate.getDate() + 7); // Add 7 days
console.log(futureDate);
        </pre>
    </ul>
</div>

<!-- JavaScript JSON -->
<div class="section">
    <h2>52. JavaScript JSON</h2>
    <p>JSON (JavaScript Object Notation) is a format for representing structured data as text.</p>
    <ul>
        <li><strong>Parsing JSON:</strong> Use <code>JSON.parse()</code> to convert a JSON string into a JavaScript object.</li>
        <pre>
const jsonString = '{"name": "John", "age": 30}';
const jsonObject = JSON.parse(jsonString);
console.log(jsonObject.name); // John
        </pre>

        <li><strong>Stringifying Objects:</strong> Use <code>JSON.stringify()</code> to convert a JavaScript object into a JSON string.</li>
        <pre>
const obj = { name: 'Jane', age: 25 };
const jsonStr = JSON.stringify(obj);
console.log(jsonStr); // {"name":"Jane","age":25}
        </pre>

        <li><strong>Handling JSON Errors:</strong> Use try...catch to handle errors that may occur during parsing or stringifying JSON.</li>
        <pre>
try {
  const invalidJson = '{name: John}';
  JSON.parse(invalidJson);
} catch (error) {
  console.error('Invalid JSON:', error);
}
        </pre>
    </ul>
</div>
<!-- JavaScript Asynchronous JavaScript and XML (AJAX) -->
<div class="section">
    <h2>53. JavaScript Asynchronous JavaScript and XML (AJAX)</h2>
    <p>AJAX is a technique used to make asynchronous HTTP requests to a server without reloading the page.</p>
    <ul>
        <li><strong>Using XMLHttpRequest:</strong> Create an instance of <code>XMLHttpRequest</code> to perform AJAX requests.</li>
        <pre>
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://api.example.com/data', true);
xhr.onreadystatechange = function() {
  if (xhr.readyState === 4 && xhr.status === 200) {
    console.log(xhr.responseText);
  }
};
xhr.send();
        </pre>

        <li><strong>Using Fetch API:</strong> The Fetch API provides a modern, promise-based approach for making AJAX requests.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Handling Responses:</strong> Parse and handle server responses in JSON, text, or other formats.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    // Process the data
    console.log(data);
  });
        </pre>
    </ul>
</div>

<!-- JavaScript Promises -->
<div class="section">
    <h2>54. JavaScript Promises</h2>
    <p>Promises are used to handle asynchronous operations by representing a value that may be available now, or in the future, or never.</p>
    <ul>
        <li><strong>Creating Promises:</strong> Use the <code>Promise</code> constructor to create a new promise.</li>
        <pre>
const myPromise = new Promise((resolve, reject) => {
  let success = true;
  if (success) {
    resolve('The operation was successful.');
  } else {
    reject('The operation failed.');
  }
});
        </pre>

        <li><strong>Consuming Promises:</strong> Use <code>then()</code> and <code>catch()</code> methods to handle the resolved value or any errors.</li>
        <pre>
myPromise
  .then(result => console.log(result))
  .catch(error => console.error(error));
        </pre>

        <li><strong>Promise Chaining:</strong> Chain multiple <code>then()</code> methods to handle a sequence of asynchronous operations.</li>
        <pre>
myPromise
  .then(result => {
    return result + ' Chaining promises.';
  })
  .then(newResult => console.log(newResult))
  .catch(error => console.error(error));
        </pre>
    </ul>
</div>

<!-- JavaScript Async/Await -->
<div class="section">
    <h2>55. JavaScript Async/Await</h2>
    <p>Async/await is a syntactic sugar built on top of promises, providing a more readable and synchronous-looking code for asynchronous operations.</p>
    <ul>
        <li><strong>Using Async/Await:</strong> Mark a function with <code>async</code> and use <code>await</code> to handle promises.</li>
        <pre>
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error:', error);
  }
}

fetchData();
        </pre>

        <li><strong>Handling Multiple Promises:</strong> Use <code>Promise.all()</code> to handle multiple promises simultaneously.</li>
        <pre>
async function fetchMultipleData() {
  try {
    const [response1, response2] = await Promise.all([
      fetch('https://api.example.com/data1'),
      fetch('https://api.example.com/data2')
    ]);
    const data1 = await response1.json();
    const data2 = await response2.json();
    console.log(data1, data2);
  } catch (error) {
    console.error('Error:', error);
  }
}

fetchMultipleData();
        </pre>
    </ul>
</div>

<!-- JavaScript Modules -->
<div class="section">
    <h2>56. JavaScript Modules</h2>
    <p>Modules are used to encapsulate code into reusable pieces, improving maintainability and organization.</p>
    <ul>
        <li><strong>Exporting Modules:</strong> Use <code>export</code> to make functions, objects, or values available to other modules.</li>
        <pre>
// utils.js
export function greet(name) {
  return `Hello, ${name}!`;
}
        </pre>

        <li><strong>Importing Modules:</strong> Use <code>import</code> to include exported functionalities from other modules.</li>
        <pre>
// main.js
import { greet } from './utils.js';

console.log(greet('World')); // Hello, World!
        </pre>

        <li><strong>Default Exports:</strong> Use <code>export default</code> to export a single value or function as the default export from a module.</li>
        <pre>
// utils.js
export default function greet(name) {
  return `Hello, ${name}!`;
}
        </pre>

        <pre>
// main.js
import greet from './utils.js';

console.log(greet('World')); // Hello, World!
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling with try...catch -->
<div class="section">
    <h2>57. JavaScript Error Handling with try...catch</h2>
    <p>Use <code>try...catch</code> to handle exceptions and prevent your code from crashing due to runtime errors.</p>
    <ul>
        <li><strong>Basic Syntax:</strong> Wrap code that may throw an error in a <code>try</code> block, and handle the error in the <code>catch</code> block.</li>
        <pre>
try {
  // Code that may throw an error
  let result = riskyOperation();
} catch (error) {
  console.error('An error occurred:', error);
}
        </pre>

        <li><strong>Finally Block:</strong> Use <code>finally</code> to execute code regardless of whether an error occurred or not.</li>
        <pre>
try {
  // Code that may throw an error
  let result = riskyOperation();
} catch (error) {
  console.error('An error occurred:', error);
} finally {
  console.log('This will run regardless of an error.');
}
        </pre>

        <li><strong>Custom Error Handling:</strong> Create custom error types for more specific error handling.</li>
        <pre>
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = 'CustomError';
  }
}

try {
  throw new CustomError('This is a custom error');
} catch (error) {
  if (error instanceof CustomError) {
    console.error('CustomError:', error.message);
  } else {
    console.error('General Error:', error.message);
  }
}
        </pre>
    </ul>
</div>

<!-- JavaScript Web APIs -->
<div class="section">
    <h2>58. JavaScript Web APIs</h2>
    <p>Web APIs are built-in APIs provided by the browser to interact with various web functionalities.</p>
    <ul>
        <li><strong>Geolocation API:</strong> Access the user's location information.</li>
        <pre>
navigator.geolocation.getCurrentPosition((position) => {
  console.log('Latitude:', position.coords.latitude);
  console.log('Longitude:', position.coords.longitude);
}, (error) => {
  console.error('Error:', error);
});
        </pre>

        <li><strong>Local Storage API:</strong> Store data locally in the browser.</li>
        <pre>
localStorage.setItem('key', 'value');
const value = localStorage.getItem('key');
console.log(value); // value
        </pre>

        <li><strong>Session Storage API:</strong> Similar to local storage, but data is cleared when the page session ends.</li>
        <pre>
sessionStorage.setItem('key', 'value');
const value = sessionStorage.getItem('key');
console.log(value); // value
        </pre>

        <li><strong>Fetch API:</strong> Make network requests to servers.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>
    </ul>
</div>
<!-- JavaScript DOM Manipulation -->
<div class="section">
    <h2>59. JavaScript DOM Manipulation</h2>
    <p>DOM manipulation involves using JavaScript to change the structure, style, or content of a web page.</p>
    <ul>
        <li><strong>Selecting Elements:</strong> Use methods like <code>getElementById()</code>, <code>getElementsByClassName()</code>, and <code>querySelector()</code> to select DOM elements.</li>
        <pre>
const elementById = document.getElementById('myId');
const elementsByClass = document.getElementsByClassName('myClass');
const firstElement = document.querySelector('.myClass');
        </pre>

        <li><strong>Changing Content:</strong> Use properties like <code>innerHTML</code>, <code>textContent</code>, or <code>innerText</code> to modify element content.</li>
        <pre>
const element = document.getElementById('myElement');
element.innerHTML = 'New content';
element.textContent = 'Text content';
        </pre>

        <li><strong>Manipulating Attributes:</strong> Use <code>setAttribute()</code>, <code>getAttribute()</code>, and <code>removeAttribute()</code> to manipulate element attributes.</li>
        <pre>
const img = document.querySelector('img');
img.setAttribute('src', 'new-image.jpg');
const src = img.getAttribute('src');
img.removeAttribute('alt');
        </pre>

        <li><strong>Creating and Inserting Elements:</strong> Use <code>createElement()</code>, <code>appendChild()</code>, and <code>insertBefore()</code> to create and add new elements to the DOM.</li>
        <pre>
const newDiv = document.createElement('div');
newDiv.textContent = 'Hello, World!';
document.body.appendChild(newDiv);
        </pre>
    </ul>
</div>

<!-- JavaScript Event Handling -->
<div class="section">
    <h2>60. JavaScript Event Handling</h2>
    <p>Event handling allows you to respond to user actions like clicks, key presses, and form submissions.</p>
    <ul>
        <li><strong>Adding Event Listeners:</strong> Use <code>addEventListener()</code> to attach event handlers to elements.</li>
        <pre>
const button = document.querySelector('button');
button.addEventListener('click', () => {
  alert('Button clicked!');
});
        </pre>

        <li><strong>Event Object:</strong> The event object provides information about the event and the element that triggered it.</li>
        <pre>
button.addEventListener('click', (event) => {
  console.log(event.target); // The clicked element
});
        </pre>

        <li><strong>Removing Event Listeners:</strong> Use <code>removeEventListener()</code> to detach event handlers.</li>
        <pre>
const handleClick = () => alert('Button clicked!');
button.addEventListener('click', handleClick);
button.removeEventListener('click', handleClick);
        </pre>

        <li><strong>Event Delegation:</strong> Use event delegation to handle events at a higher level in the DOM tree for better performance.</li>
        <pre>
document.body.addEventListener('click', (event) => {
  if (event.target.matches('button')) {
    console.log('Button clicked!');
  }
});
        </pre>
    </ul>
</div>

<!-- JavaScript Closures -->
<div class="section">
    <h2>61. JavaScript Closures</h2>
    <p>Closures are functions that retain access to their lexical scope even after their outer function has finished executing.</p>
    <ul>
        <li><strong>Creating Closures:</strong> A closure is created when a function is defined within another function, allowing the inner function to access variables from the outer function.</li>
        <pre>
function outerFunction() {
  let outerVariable = 'I am from outer function';
  function innerFunction() {
    console.log(outerVariable);
  }
  return innerFunction;
}

const closure = outerFunction();
closure(); // Logs: I am from outer function
        </pre>

        <li><strong>Practical Use Cases:</strong> Closures are useful for data encapsulation, creating private variables, and implementing factory functions.</li>
        <pre>
function createCounter() {
  let count = 0;
  return function() {
    count += 1;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
        </pre>
    </ul>
</div>

<!-- JavaScript Object-Oriented Programming (OOP) -->
<div class="section">
    <h2>62. JavaScript Object-Oriented Programming (OOP)</h2>
    <p>OOP is a programming paradigm that uses objects to represent data and methods to operate on that data.</p>
    <ul>
        <li><strong>Creating Classes:</strong> Use the <code>class</code> keyword to create classes in JavaScript.</li>
        <pre>
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Hello, my name is ${this.name}`);
  }
}

const person = new Person('Alice', 30);
person.greet(); // Hello, my name is Alice
        </pre>

        <li><strong>Inheritance:</strong> Use the <code>extends</code> keyword to create subclasses and inherit properties and methods from a parent class.</li>
        <pre>
class Employee extends Person {
  constructor(name, age, position) {
    super(name, age);
    this.position = position;
  }

  getDetails() {
    console.log(`${this.name} is a ${this.position}`);
  }
}

const employee = new Employee('Bob', 40, 'Engineer');
employee.getDetails(); // Bob is a Engineer
        </pre>

        <li><strong>Encapsulation:</strong> Use private fields and methods to protect the internal state of an object.</li>
        <pre>
class BankAccount {
  #balance = 0;

  deposit(amount) {
    if (amount > 0) {
      this.#balance += amount;
    }
  }

  getBalance() {
    return this.#balance;
  }
}

const account = new BankAccount();
account.deposit(100);
console.log(account.getBalance()); // 100
        </pre>
    </ul>
</div>

<!-- JavaScript Modules and Namespace -->
<div class="section">
    <h2>63. JavaScript Modules and Namespace</h2>
    <p>Modules help in organizing code by separating it into files and namespaces prevent naming conflicts.</p>
    <ul>
        <li><strong>Exporting and Importing Modules:</strong> Use <code>export</code> and <code>import</code> to share functionality between files.</li>
        <pre>
/* math.js */
export function add(a, b) {
  return a + b;
}

/* app.js */
import { add } from './math.js';
console.log(add(2, 3)); // 5
        </pre>

        <li><strong>Default Exports:</strong> Use <code>export default</code> to export a single value or function from a module.</li>
        <pre>
/* utils.js */
export default function log(message) {
  console.log(message);
}

/* main.js */
import log from './utils.js';
log('Hello World'); // Hello World
        </pre>

        <li><strong>Namespaces:</strong> Use objects to create namespaces and avoid global variable conflicts.</li>
        <pre>
const MyNamespace = {
  greet(name) {
    console.log(`Hello, ${name}`);
  }
};

MyNamespace.greet('Alice'); // Hello, Alice
        </pre>
    </ul>
</div>

<!-- JavaScript Regular Expressions -->
<div class="section">
    <h2>64. JavaScript Regular Expressions</h2>
    <p>Regular expressions (regex) are patterns used to match character combinations in strings.</p>
    <ul>
        <li><strong>Creating Regular Expressions:</strong> Use <code>/pattern/</code> or <code>new RegExp('pattern')</code> to create regex objects.</li>
        <pre>
const regex1 = /hello/i;
const regex2 = new RegExp('hello', 'i');
        </pre>

        <li><strong>Testing Patterns:</strong> Use <code>test()</code> to check if a pattern matches a string.</li>
        <pre>
const regex = /world/;
console.log(regex.test('Hello world')); // true
        </pre>

        <li><strong>Matching Patterns:</strong> Use <code>exec()</code> to retrieve matched results and <code>match()</code> to find matches in strings.</li>
        <pre>
const regex = /(\d+)/;
const result = regex.exec('There are 42 apples');
console.log(result[1]); // 42

const str = 'There are 42 apples';
const matches = str.match(/\d+/);
console.log(matches[0]); // 42
        </pre>

        <li><strong>Replacing Patterns:</strong> Use <code>replace()</code> to replace occurrences of patterns in strings.</li>
        <pre>
const str = 'Hello, world!';
const newStr = str.replace(/world/, 'JavaScript');
console.log(newStr); // Hello, JavaScript!
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling -->
<div class="section">
    <h2>65. JavaScript Error Handling</h2>
    <p>Handling errors is crucial for creating robust applications. JavaScript provides mechanisms to catch and handle errors gracefully.</p>
    <ul>
        <li><strong>try...catch Statement:</strong> Use <code>try...catch</code> to catch and handle errors that occur during execution.</li>
        <pre>
try {
  // Code that might throw an error
  let result = riskyFunction();
} catch (error) {
  console.error('Caught an error:', error);
}
        </pre>

        <li><strong>throw Statement:</strong> Use <code>throw</code> to manually throw exceptions when necessary.</li>
        <pre>
function checkValue(value) {
  if (value <= 0) {
    throw new Error('Value must be greater than zero');
  }
  return value;
}

try {
  checkValue(0);
} catch (error) {
  console.error('Error:', error.message);
}
        </pre>

        <li><strong>Custom Error Types:</strong> Create custom error classes to provide more specific error handling.</li>
        <pre>
class ValidationError extends Error {
  constructor(message) {
    super(message);
    this.name = 'ValidationError';
  }
}

try {
  throw new ValidationError('Invalid input');
} catch (error) {
  if (error instanceof ValidationError) {
    console.error('Validation Error:', error.message);
  } else {
    console.error('General Error:', error.message);
  }
}
        </pre>
    </ul>
</div>
<!-- JavaScript Asynchronous Programming -->
<div class="section">
    <h2>66. JavaScript Asynchronous Programming</h2>
    <p>Asynchronous programming allows you to perform operations without blocking the main thread, making your web applications more responsive.</p>
    <ul>
        <li><strong>Callbacks:</strong> Functions that are passed as arguments to other functions and are executed after the completion of an operation.</li>
        <pre>
function fetchData(callback) {
  setTimeout(() => {
    callback('Data loaded');
  }, 1000);
}

fetchData(data => {
  console.log(data); // Data loaded
});
        </pre>

        <li><strong>Promises:</strong> Objects representing the eventual completion or failure of an asynchronous operation and its resulting value.</li>
        <pre>
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('Data loaded');
  }, 1000);
});

promise.then(data => {
  console.log(data); // Data loaded
}).catch(error => {
  console.error(error);
});
        </pre>

        <li><strong>Async/Await:</strong> Syntax for working with promises that makes asynchronous code look and behave more like synchronous code.</li>
        <pre>
async function fetchData() {
  try {
    const response = await new Promise((resolve, reject) => {
      setTimeout(() => {
        resolve('Data loaded');
      }, 1000);
    });
    console.log(response); // Data loaded
  } catch (error) {
    console.error(error);
  }
}

fetchData();
        </pre>

        <li><strong>Handling Multiple Promises:</strong> Use <code>Promise.all()</code> to execute multiple promises in parallel and wait for all of them to complete.</li>
        <pre>
const promise1 = Promise.resolve('First');
const promise2 = Promise.resolve('Second');

Promise.all([promise1, promise2])
  .then(results => {
    console.log(results); // ['First', 'Second']
  })
  .catch(error => {
    console.error(error);
  });
        </pre>
    </ul>
</div>

<!-- JavaScript Web APIs -->
<div class="section">
    <h2>67. JavaScript Web APIs</h2>
    <p>Web APIs provide JavaScript with the ability to interact with various features of the web browser.</p>
    <ul>
        <li><strong>Fetch API:</strong> Provides an interface for making network requests similar to XMLHttpRequest but with a simpler and more powerful API.</li>
        <pre>
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => console.log(data))
  .catch(error => console.error('Error:', error));
        </pre>

        <li><strong>Local Storage and Session Storage:</strong> Web storage APIs that allow storing data in the browser. <code>localStorage</code> persists data across sessions, while <code>sessionStorage</code> only persists data for the current session.</li>
        <pre>
localStorage.setItem('key', 'value');
const value = localStorage.getItem('key');
localStorage.removeItem('key');

sessionStorage.setItem('sessionKey', 'sessionValue');
const sessionValue = sessionStorage.getItem('sessionKey');
sessionStorage.removeItem('sessionKey');
        </pre>

        <li><strong>Geolocation API:</strong> Provides access to the user's geographic location.</li>
        <pre>
navigator.geolocation.getCurrentPosition(position => {
  console.log('Latitude:', position.coords.latitude);
  console.log('Longitude:', position.coords.longitude);
}, error => {
  console.error('Error:', error);
});
        </pre>

        <li><strong>WebSockets:</strong> Provides a way to open a persistent connection to a server and exchange data in real-time.</li>
        <pre>
const socket = new WebSocket('wss://example.com/socket');

socket.addEventListener('open', () => {
  socket.send('Hello Server!');
});

socket.addEventListener('message', event => {
  console.log('Message from server:', event.data);
});

socket.addEventListener('close', () => {
  console.log('Connection closed');
});

socket.addEventListener('error', error => {
  console.error('WebSocket Error:', error);
});
        </pre>
    </ul>
</div>

<!-- JavaScript Debugging -->
<div class="section">
    <h2>68. JavaScript Debugging</h2>
    <p>Debugging is the process of identifying and fixing errors in your code. JavaScript offers several tools and techniques for effective debugging.</p>
    <ul>
        <li><strong>Console Methods:</strong> Use <code>console.log()</code>, <code>console.error()</code>, <code>console.warn()</code>, and other console methods to output debug information.</li>
        <pre>
console.log('Debug message');
console.error('Error message');
console.warn('Warning message');
        </pre>

        <li><strong>Breakpoints:</strong> Set breakpoints in browser developer tools to pause execution and inspect variables and call stacks.</li>
        <pre>
Open Developer Tools (F12 or Ctrl+Shift+I)
Go to the 'Sources' tab
Click on the line number to set a breakpoint
        </pre>

        <li><strong>Debugger Statement:</strong> Use the <code>debugger</code> statement to pause code execution and invoke the debugger.</li>
        <pre>
function calculate() {
  debugger; // Execution will pause here
  return 2 + 2;
}
calculate();
        </pre>

        <li><strong>Network Requests:</strong> Use the Network tab in developer tools to monitor and debug network requests and responses.</li>
        <pre>
Open Developer Tools (F12 or Ctrl+Shift+I)
Go to the 'Network' tab
Monitor requests, responses, and their timings
        </pre>
    </ul>
</div>

<!-- JavaScript Performance Optimization -->
<div class="section">
    <h2>69. JavaScript Performance Optimization</h2>
    <p>Optimizing performance involves improving the speed and responsiveness of your JavaScript code and web applications.</p>
    <ul>
        <li><strong>Minimizing Reflows and Repaints:</strong> Reduce the number of layout changes by minimizing DOM manipulations and batch updates.</li>
        <pre>
// Example of batched updates
const element = document.getElementById('myElement');
element.style.backgroundColor = 'red';
element.style.width = '100px';
element.style.height = '100px';
        </pre>

        <li><strong>Using Efficient Selectors:</strong> Optimize DOM queries by using efficient selectors and caching results.</li>
        <pre>
const elements = document.querySelectorAll('.myClass');
// Cache results if used multiple times
        </pre>

        <li><strong>Debouncing and Throttling:</strong> Use debouncing and throttling techniques to limit the rate at which functions are executed in response to events.</li>
        <pre>
function debounce(func, delay) {
  let timeout;
  return function(...args) {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, args), delay);
  };
}

window.addEventListener('resize', debounce(() => {
  console.log('Resize event');
}, 200));
        </pre>

        <li><strong>Profiling and Monitoring:</strong> Use browser developer tools to profile JavaScript performance and identify bottlenecks.</li>
        <pre>
Open Developer Tools (F12 or Ctrl+Shift+I)
Go to the 'Performance' tab
Record and analyze performance data
        </pre>
    </ul>
</div>
<!-- JavaScript Advanced Concepts -->
<div class="section">
    <h2>70. JavaScript Advanced Concepts</h2>
    <p>Advanced JavaScript concepts enhance your understanding and ability to write more sophisticated and efficient code.</p>
    <ul>
        <li><strong>Closures:</strong> Functions that have access to variables from their outer scope even after the outer function has finished executing.</li>
        <pre>
function outerFunction() {
  const outerVariable = 'I am outside!';
  return function innerFunction() {
    console.log(outerVariable); // I am outside!
  };
}

const closure = outerFunction();
closure();
        </pre>

        <li><strong>Prototypes and Inheritance:</strong> JavaScript uses prototypes for inheritance. Every object has a prototype, and you can extend objects with additional properties and methods.</li>
        <pre>
function Animal(name) {
  this.name = name;
}

Animal.prototype.speak = function() {
  console.log(`${this.name} makes a noise.`);
};

const dog = new Animal('Dog');
dog.speak(); // Dog makes a noise.
        </pre>

        <li><strong>Async Iterators:</strong> Provide a way to work with asynchronous data sources using the <code>for await...of</code> loop.</li>
        <pre>
async function* asyncGenerator() {
  yield 'First';
  yield 'Second';
  yield 'Third';
}

for await (const value of asyncGenerator()) {
  console.log(value);
}
        </pre>

        <li><strong>Generators:</strong> Functions that can be paused and resumed, allowing you to generate a sequence of values lazily.</li>
        <pre>
function* generatorFunction() {
  yield 'First';
  yield 'Second';
  yield 'Third';
}

const generator = generatorFunction();

console.log(generator.next().value); // First
console.log(generator.next().value); // Second
console.log(generator.next().value); // Third
        </pre>

        <li><strong>Decorators:</strong> Special functions that can be used to modify the behavior of classes or methods (proposed feature in ECMAScript).</li>
        <pre>
function log(target, key, descriptor) {
  const originalMethod = descriptor.value;
  descriptor.value = function(...args) {
    console.log(`Called ${key} with`, args);
    return originalMethod.apply(this, args);
  };
  return descriptor;
}

class Example {
  @log
  method(value) {
    console.log('Value:', value);
  }
}

const example = new Example();
example.method('test'); // Called method with ['test'] \n Value: test
        </pre>
    </ul>
</div>

<!-- JavaScript Error Handling -->
<div class="section">
    <h2>71. JavaScript Error Handling</h2>
    <p>Error handling is essential for managing exceptions and ensuring that your code runs smoothly even when unexpected issues occur.</p>
    <ul>
        <li><strong>try...catch Statement:</strong> Allows you to handle errors that occur during code execution.</li>
        <pre>
try {
  throw new Error('Something went wrong!');
} catch (error) {
  console.error(error.message); // Something went wrong!
}
        </pre>

        <li><strong>finally Block:</strong> Executes code after <code>try</code> and <code>catch</code>, regardless of whether an error occurred.</li>
        <pre>
try {
  // Code that may throw an error
} catch (error) {
  console.error(error);
} finally {
  console.log('This will always run');
}
        </pre>

        <li><strong>Custom Errors:</strong> Create custom error types by extending the built-in <code>Error</code> class.</li>
        <pre>
class CustomError extends Error {
  constructor(message) {
    super(message);
    this.name = 'CustomError';
  }
}

throw new CustomError('This is a custom error!');
        </pre>

        <li><strong>Promise Error Handling:</strong> Handle errors in asynchronous code with <code>catch</code> or <code>try...catch</code> within async functions.</li>
        <pre>
const promise = new Promise((resolve, reject) => {
  reject('Promise error');
});

promise.catch(error => {
  console.error(error); // Promise error
});
        </pre>
    </ul>
</div>

<!-- JavaScript ES6+ Features -->
<div class="section">
    <h2>72. JavaScript ES6+ Features</h2>
    <p>ES6 (ECMAScript 2015) and later versions introduced many new features that simplify code and improve performance.</p>
    <ul>
        <li><strong>Arrow Functions:</strong> Provide a shorter syntax for writing functions and lexically bind the <code>this</code> keyword.</li>
        <pre>
const add = (a, b) => a + b;
console.log(add(2, 3)); // 5
        </pre>

        <li><strong>Template Literals:</strong> Allow you to embed expressions within strings and create multi-line strings.</li>
        <pre>
const name = 'World';
const greeting = `Hello, ${name}!`;
console.log(greeting); // Hello, World!
        </pre>

        <li><strong>Destructuring Assignment:</strong> Extract values from arrays or properties from objects into distinct variables.</li>
        <pre>
const [a, b] = [1, 2];
console.log(a, b); // 1 2

const { x, y } = { x: 10, y: 20 };
console.log(x, y); // 10 20
        </pre>

        <li><strong>Spread and Rest Operators:</strong> Spread syntax expands arrays into individual elements, while rest syntax collects multiple elements into an array.</li>
        <pre>
const arr = [1, 2, 3];
const newArr = [...arr, 4, 5];
console.log(newArr); // [1, 2, 3, 4, 5]

function sum(...numbers) {
  return numbers.reduce((acc, num) => acc + num, 0);
}
console.log(sum(1, 2, 3, 4)); // 10
        </pre>

        <li><strong>Classes:</strong> Provide a clear syntax for creating objects and dealing with inheritance.</li>
        <pre>
class Animal {
  constructor(name) {
    this.name = name;
  }

  speak() {
    console.log(`${this.name} makes a noise.`);
  }
}

class Dog extends Animal {
  bark() {
    console.log(`${this.name} barks.`);
  }
}

const dog = new Dog('Rex');
dog.speak(); // Rex makes a noise.
dog.bark();  // Rex barks.
        </pre>

        <li><strong>Modules:</strong> Allow you to import and export code between files, improving code organization and reuse.</li>
        <pre>
// module.js
export const pi = 3.14;
export function square(x) {
  return x * x;
}

// main.js
import { pi, square } from './module.js';
console.log(pi); // 3.14
console.log(square(5)); // 25
        </pre>
    </ul>
</div>

</body>
</html>